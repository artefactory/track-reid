{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the documentation","text":"<p>This repository aims to implement a modular library for correcting tracking results. By tracking, we mean:</p> <ul> <li>On a sequence of images, an initial detection algorithm (e.g., yolo, fast-RCNN) is applied upstream.</li> <li>A tracking algorithm (e.g., Bytetrack, Strongsort) is then applied to the detections with the aim of assigning a unique ID to each different object and tracking these objects, i.e., maintaining the unique ID throughout the image sequence.</li> </ul> <p>Overall, state-of-the-art (SOTA) tracking algorithms perform well in cases of constant speed movements, with detections not evolving (shape of bounding boxes relatively constant), which does not fit many real use cases. In practice, we end up with a lot of ID switches, and far too many unique IDs compared to the number of different objects. Therefore, we propose here a library for re-matching IDs, based on a tracking result, and allowing to reassign object IDs to ensure uniqueness.</p> <p>Here is an example of the track reid library, used to correct jungling balls tracking results on a short video.</p> <p> Bytetrack x yolov8l, 42 tracked objects </p> <p> Bytetrack x yolov8l + track-reid, 4 tracked objects  </p> <p>For more insight on how to get started, please refer to this guide for users, or this guide for developers.</p>"},{"location":"custom_cost_selection/","title":"Designing custom cost and selection functions","text":""},{"location":"custom_cost_selection/#custom-cost-function","title":"Custom cost function","text":"<p>In our codebase, a cost function is utilized to quantify the dissimilarity between two objects, specifically instances of TrackedObject. The cost function plays a pivotal role in the matching process within the Matcher class, where it computes a cost matrix. Each element in this matrix represents the cost of assigning a candidate to a switcher. For a deeper understanding of cost functions, please refer to the related documentation.</p> <p>When initializing the ReidProcessor, you have the option to provide a custom cost function. The requirements for designing one are as follows:</p> <ul> <li>The cost function must accept 2 TrackedObjects instances: a candidate (a new object that appears and can potentially be matched), and a switcher (an object that has been lost and can potentially be re-matched).</li> <li>All the metadata of each TrackedObject can be utilized to compute a cost.</li> <li>If additional metadata is required, you should modify the metadata class accordingly. Please refer to the developer quickstart documentation if needed.</li> </ul> <p>Here is an example of an Intersection over Union (IoU) distance function that you can use:</p> <pre><code>def bounding_box_iou_distance(candidate: TrackedObject, switcher: TrackedObject) -&gt; float:\n\"\"\"\n    Calculates the Intersection over Union (IoU) between the bounding boxes of two TrackedObjects.\n    This measure is used as a measure of similarity between the two objects, with a higher IoU\n    indicating a higher likelihood of the objects being the same.\n\n    Args:\n        candidate (TrackedObject): The first TrackedObject.\n        switcher (TrackedObject): The second TrackedObject.\n\n    Returns:\n        float: The IoU between the bounding boxes of the two TrackedObjects.\n    \"\"\"\n    # Get the bounding boxes from the Metadata of each TrackedObject\n    bbox1 = candidate.metadata.bbox\n    bbox2 = switcher.metadata.bbox\n\n    # Calculate the intersection of the bounding boxes\n    x1 = max(bbox1[0], bbox2[0])\n    y1 = max(bbox1[1], bbox2[1])\n    x2 = min(bbox1[2], bbox2[2])\n    y2 = min(bbox1[3], bbox2[3])\n\n    # If the bounding boxes do not overlap, return 0\n    if x2 &lt; x1 or y2 &lt; y1:\n        return 0.0\n\n    # Calculate the area of the intersection\n    intersection_area = (x2 - x1) * (y2 - y1)\n\n    # Calculate the area of each bounding box\n    bbox1_area = (bbox1[2] - bbox1[0]) * (bbox1[3] - bbox1[1])\n    bbox2_area = (bbox2[2] - bbox2[0]) * (bbox2[3] - bbox2[1])\n\n    # Calculate the IoU\n    iou = intersection_area / float(bbox1_area + bbox2_area - intersection_area)\n\n    return 1 - iou\n</code></pre> <p>Next, pass this function during the initialization of your ReidProcessor:</p> <pre><code>reid_processor = ReidProcessor(cost_function_threshold=0.3,\n                               cost_function = bounding_box_iou_distance,\n                               filter_confidence_threshold=...,\n                               filter_time_threshold=...,\n                               max_attempt_to_match=...,\n                               max_frames_to_rematch=...,\n                               save_to_txt=True,\n                               file_path=\"your_file.txt\")\n</code></pre> <p>In this case, candidates and switchers with bounding boxes will be matched if their IoU is below 0.7. Among possible matches, the two bounding boxes with the lowest cost (i.e., larger IoU) will be matched. You can use all the available metadata. For instance, here is an example of a cost function based on the difference in confidence:</p> <pre><code>def confidence_difference(candidate: TrackedObject, switcher: TrackedObject) -&gt; float:\n\"\"\"\n    Calculates the absolute difference between the confidence values of two TrackedObjects.\n    This measure is used as a measure of dissimilarity between the two objects, with a smaller difference\n    indicating a higher likelihood of the objects being the same.\n\n    Args:\n        candidate (TrackedObject): The first TrackedObject.\n        switcher (TrackedObject): The second TrackedObject.\n\n    Returns:\n        float: The absolute difference between the confidence values of the two TrackedObjects.\n    \"\"\"\n    # Get the confidence values from the Metadata of each TrackedObject\n    confidence1 = candidate.metadata.confidence\n    confidence2 = switcher.metadata.confidence\n\n    # Calculate the absolute difference between the confidence values\n    difference = abs(confidence1 - confidence2)\n\n    return difference\n</code></pre> <p>Then, pass this function during the initialization of your ReidProcessor:</p> <pre><code>reid_processor = ReidProcessor(cost_function_threshold=0.1,\n                               cost_function = confidence_difference,\n                               filter_confidence_threshold=...,\n                               filter_time_threshold=...,\n                               max_attempt_to_match=...,\n                               max_frames_to_rematch=...,\n                               save_to_txt=True,\n                               file_path=\"your_file.txt\")\n</code></pre> <p>In this case, candidates and switchers will be matched if their confidence is similar, with a threshold acceptance of 0.1. Among possible matches, the two objects with the lowest cost (i.e., lower confidence difference) will be matched.</p>"},{"location":"custom_cost_selection/#custom-selection-function","title":"Custom Selection function","text":"<p>In the codebase, a selection function is used to determine whether two objects, specifically TrackedObjects instances, should be considered for matching. The selection function is a key part of the matching process in the Matcher class. For a deeper understanding of selection functions, please refer to the related documentation.</p> <p>Here is an example of a selection function per zone that you can use:</p> <pre><code># Define the area of interest, [x_min, y_min, x_max, y_max]\nAREA_OF_INTEREST = [0, 0, 500, 500]\n\ndef select_by_area(candidate: TrackedObject, switcher: TrackedObject) -&gt; int:\n\n    # Check if both objects are inside the area of interest\n    if (candidate.bbox[0] &gt; AREA_OF_INTEREST[0] and candidate.bbox[1] &gt; AREA_OF_INTEREST[1] and\n        candidate.bbox[0] + candidate.bbox[2] &lt; AREA_OF_INTEREST[2] and candidate.bbox[1] + candidate.bbox[3] &lt; AREA_OF_INTEREST[3] and\n        switcher.bbox[0] &gt; AREA_OF_INTEREST[0] and switcher.bbox[1] &gt; AREA_OF_INTEREST[1] and\n        switcher.bbox[0] + switcher.bbox[2] &lt; AREA_OF_INTEREST[2] and switcher.bbox[1] + switcher.bbox[3] &lt; AREA_OF_INTEREST[3]):\n        return 1\n    else:\n        return 0\n</code></pre> <p>Then, pass this function during the initialization of your ReidProcessor:</p> <pre><code>reid_processor = ReidProcessor(selection_function = select_by_area,\n                               filter_confidence_threshold=...,\n                               filter_time_threshold=...,\n                               max_attempt_to_match=...,\n                               max_frames_to_rematch=...,\n                               save_to_txt=True,\n                               file_path=\"your_file.txt\")\n</code></pre> <p>In this case, candidates and switchers will be considerated for matching if they belong to the same zone. You can of course combine selection functions, for instance to selection only switchers and candidates that belong to the same area and belong to the same category.</p>"},{"location":"quickstart_dev/","title":"Quickstart developers","text":""},{"location":"quickstart_dev/#installation","title":"Installation","text":"<p>First, clone the repository to your local machine:</p> <pre><code>git clone https://github.com/artefactory-fr/track-reid.git\n</code></pre> <p>Then, navigate to the project directory:</p> <pre><code>cd track-reid\n</code></pre> <p>To install the necessary dependencies, we use Poetry. If you don't have Poetry installed, you can download it using the following command:</p> <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <p>Now, you can install the dependencies:</p> <pre><code>make install\n</code></pre> <p>This will create a virtual environment and install the necessary dependencies. To activate the virtual environment in your terminal, you can use the following command:</p> <pre><code>poetry shell\n</code></pre> <p>You can also update the requirements using the following command:</p> <pre><code>make update-requirements\n</code></pre> <p>Then, you are ready to go ! For more detailed information, please refer to the <code>Makefile</code>.</p>"},{"location":"quickstart_dev/#tests","title":"Tests","text":"<p>In this project, we have designed both integration tests and unit tests. These tests are located in the <code>tests</code> directory of the project.</p> <p>Integration tests are designed to test the interaction between different parts of the system, ensuring that they work together as expected. Those tests can be found in the <code>tests/integration_tests</code> directory of the project.</p> <p>Unit tests, on the other hand, are designed to test individual components of the system in isolation. We provided a bench of unit tests to test key functions of the project, those can be found in <code>tests/unit_tests</code>.</p> <p>To run all tests, you can use the following command:</p> <pre><code>make run_tests\n</code></pre>"},{"location":"quickstart_user/","title":"Using the ReidProcessor","text":"<p>The ReidProcessor is the entry point of the <code>track-reid</code> library. It is used to process and reconcile tracking data, ensuring consistent and accurate tracking of objects over time. Here's a step-by-step guide on how to use it:</p>"},{"location":"quickstart_user/#step-1-understand-the-usage","title":"Step 1: Understand the Usage","text":"<p>The reidentification process is applied to tracking results, which are derived from the application of a tracking algorithm on detection results for successive frames of a video. This reidentification process is applied iteratively on each tracking result, updating its internal states during the process.</p> <p>The ReidProcessor needs to be updated with the tracking results for each frame of your sequence or video. This is done by calling the update method that takes 2 arguments:</p> <ul> <li><code>frame_id</code>: an integer specifying the current frame of the video</li> <li><code>tracker_output</code>: a numpy array containing the tracking results for the current frame</li> </ul>"},{"location":"quickstart_user/#step-2-understand-the-data-format-requirements","title":"Step 2: Understand the Data Format Requirements","text":"<p>The ReidProcessor update function requires a numpy array of tracking results for the current frame as input. This data must meet specific criteria regarding data type and structure.</p> <p>All input data must be numeric, either integers or floats. Here's an example of the expected input data format based on the schema:</p> bbox (0-3) object_id (4) category (5) confidence (6) 50, 60, 120, 80 1 1 0.91 50, 60, 120, 80 2 0 0.54 <p>Each row corresponds to a tracked object.</p> <ul> <li>The first four columns denote the bounding box coordinates in the format (x, y, width, height), where x and y are the top left coordinates of the bounding box. These coordinates can be either normalized or in pixel units. These values remain unchanged during the reidentification process.</li> <li>The fifth column is the object ID assigned by the tracker, which may be adjusted during the reidentification process.</li> <li>The sixth column indicates the category of the detected object, which may also be adjusted during the reidentification process.</li> <li>The seventh column is the confidence score of the detection, which is not modified by the reidentification process.</li> </ul> <p>For additional information, you can utilize ReidProcessor.print_input_data_format_requirements.</p> <p>Here's a reformatted example of how the output data should appear, based on the schema:</p> frame_id (0) object_id (1) category (2) bbox (3-6) confidence (7) mean_confidence (8) tracker_id (9) 1 1 1 50, 60, 120, 80 0.91 0.85 1 2 2 0 50, 60, 120, 80 0.54 0.60 2 <ul> <li>The first column represents the frame identifier, indicating the frame for which the result is applicable.</li> <li>The second column is the object ID assigned by the reidentification process.</li> <li>The third column is the category of the detected object, which may be adjusted during the reidentification process.</li> <li>The next four columns represent the bounding box coordinates, which remain unchanged from the input data.</li> <li>The seventh column is the confidence of the object, which also remains unchanged from the input data.</li> <li>The eighth column indicates the average confidence of the detected object over its lifetime, from the beginning of the tracking to the current frame.</li> <li>The final column is the object ID assigned by the tracking algorithm, before the reidentification process.</li> </ul> <p>You can use ReidProcessor.print_output_data_format_information for more insight.</p>"},{"location":"quickstart_user/#step-3-understand-necessary-modules","title":"Step 3: Understand Necessary Modules","text":"<p>To make ReidProcessor work, several modules are necessary:</p> <ul> <li>TrackedObject: This class represents a tracked object. It is used within the Matcher and ReidProcessor classes.</li> <li>TrackedObjectMetadata: This class is attached to a tracked object and represents informations and properties about the object.</li> <li>TrackedObjectFilter: This class is used to filter tracked objects based on certain criteria. It is used within the ReidProcessor class.</li> <li>Matcher: This class is used to match tracked objects based on a cost function and a selection function. It is initialized within the ReidProcessor class.</li> </ul> <p>The cost and selection functions are key components of the ReidProcessor, as they will drive the matching process between lost objects and new objects during the video. Those two functions are fully customizable and can be passed as arguments of the ReidProcessor at initialization. They both take 2 TrackedObject as inputs, and perform computation based on their metadatas.</p> <ul> <li> <p>cost function: This function calculates the cost of matching two objects. It takes two TrackedObject instances as input and returns a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match. The default cost function is bounding_box_distance.</p> </li> <li> <p>selection_function: This function determines whether two objects should be considered for matching. It takes two TrackedObject instances as input and returns a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered. The default selection function is select_by_category.</p> </li> </ul> <p>In summary, prior to the matching process, filtering on which objects should be considerated is applied thought the TrackedObjectFilter. All objects are represented by the TrackedObject class, with its attached metadata represented by TrackedObjectMetadata. The ReidProcessor then uses the Matcher class with a cost function and selection function to match objects.</p>"},{"location":"quickstart_user/#step-4-initialize-reidprocessor","title":"Step 4: Initialize ReidProcessor","text":"<p>If you do not want to provide custom cost and selection function, here is an example of ReidProcessor initialization:</p> <pre><code>reid_processor = ReidProcessor(filter_confidence_threshold=0.1,\n                               filter_time_threshold=5,\n                               cost_function_threshold=5000,\n                               max_attempt_to_match=5,\n                               max_frames_to_rematch=500,\n                               save_to_txt=True,\n                               file_path=\"your_file.txt\")\n</code></pre> <p>Here is a brief explanation of each argument in the ReidProcessor function, and how you can monitor the Matcher and the TrackedObjectFilter behaviours:</p> <ul> <li> <p><code>filter_confidence_threshold</code>: Float value that sets the minimum average confidence level for a tracked object to be considered valid. Tracked objects with average confidence levels below this threshold will be ignored.</p> </li> <li> <p><code>filter_time_threshold</code>: Integer that sets the minimum number of frames a tracked object must be seen with the same id to be considered valid. Tracked objects seen less frames that this threshold will be ignored.</p> </li> <li> <p><code>cost_function_threshold</code>: This is a float value that sets the maximum cost for a match between a detection and a track. If the cost of matching a detection to a track exceeds this threshold, the match will not be made. Set to None for no limitation.</p> </li> <li> <p><code>max_attempt_to_match</code>: This is an integer that sets the maximum number of attempts to match a tracked object never seen before to a lost tracked object. If this tracked object never seen before can't be matched within this number of attempts, it will be considered a new stable tracked object.</p> </li> <li> <p><code>max_frames_to_rematch</code>: This is an integer that sets the maximum number of frames to try to rematch a tracked object that has been lost. If a lost object can't be rematch within this number of frames, it will be considered as lost forever.</p> </li> <li> <p><code>save_to_txt</code>: This is a boolean value that determines whether the tracking results should be saved to a text file. If set to True, the results will be saved to a text file.</p> </li> <li> <p><code>file_path</code>: This is a string that specifies the path to the text file where the tracking results will be saved. This argument is only relevant if save_to_txt is set to True.</p> </li> </ul> <p>For more information on how to design custom cost and selection functions, refer to this guide.</p>"},{"location":"quickstart_user/#step-5-run-reidentifiaction-process","title":"Step 5: Run reidentifiaction process","text":"<p>Suppose you have a list of frames, a model and a tracker. You can call the <code>ReidProcessor</code> update method on each outputs of your tracker as follow:</p> <pre><code>for frame_id, image_filename in enumerate(available_frames):\n    img = cv2.imread(image_filename)\n    detections = model.predict(img)\n    tracked_objects = tracker.update(detections, frame_id)\n    corrected_tracked_objects = reid_processor.update(tracked_objects, frame_id)\n</code></pre> <p>At the end of the for loop, information about the correction can be retrieved using the <code>ReidProcessor</code> properties. For instance, the list of tracked object can be accessed using:</p> <pre><code>reid_processor.seen_objects()\n</code></pre> <p>For a complete example you can refer to examples/trackreid/starter_kit_reid.ipynb</p>"},{"location":"reference/cost_functions/","title":"Cost functions","text":"<p>In the codebase, a cost function is used to measure the dissimilarity between two objects, specifically TrackedObjects instances. The cost function is a crucial part of the matching process in the Matcher class. It calculates a cost matrix, where each element represents the cost of assigning a candidate to a switcher.</p> <p>The cost function affects the behavior of the matching process in the following ways:</p> <ol> <li> <p>Determining Matches: The cost function is used to determine the best matches between candidates and switchers. The lower the cost, the higher the likelihood that two objects are the same.</p> </li> <li> <p>Influencing Match Quality: The choice of cost function can greatly influence the quality of the matches. For example, a cost function that calculates the Euclidean distance between the centers of bounding boxes might be more suitable for tracking objects in a video, while a cost function that calculates the absolute difference between confidence values might be more suitable for matching objects based on their detection confidence.</p> </li> <li> <p>Setting Match Thresholds: The cost function also plays a role in setting thresholds for matches. In the Matcher class, if the cost exceeds a certain threshold, the match is discarded.</p> </li> </ol> <p>You can provide a custom cost function to the reidentification process. For more information, please refer to this documentation.</p>"},{"location":"reference/cost_functions/#trackreid.cost_functions.bounding_box_distance","title":"<code>bounding_box_distance</code>","text":""},{"location":"reference/cost_functions/#trackreid.cost_functions.bounding_box_distance.bounding_box_distance","title":"<code>bounding_box_distance(candidate, switcher)</code>","text":"<p>Calculates the Euclidean distance between the centers of the bounding boxes of two TrackedObjects. This distance is used as a measure of dissimilarity between the two objects, with a smaller distance indicating a higher likelihood of the objects being the same.</p> <p>Parameters:</p> Name Type Description Default <code>candidate</code> <code>TrackedObject</code> <p>The first TrackedObject.</p> required <code>switcher</code> <code>TrackedObject</code> <p>The second TrackedObject.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The Euclidean distance between the centers of the bounding boxes of the two TrackedObjects.</p> Source code in <code>trackreid/cost_functions/bounding_box_distance.py</code> <pre><code>def bounding_box_distance(candidate: TrackedObject, switcher: TrackedObject) -&gt; float:\n\"\"\"\n    Calculates the Euclidean distance between the centers of the bounding boxes of two TrackedObjects.\n    This distance is used as a measure of dissimilarity between the two objects, with a smaller distance\n    indicating a higher likelihood of the objects being the same.\n\n    Args:\n        candidate (TrackedObject): The first TrackedObject.\n        switcher (TrackedObject): The second TrackedObject.\n\n    Returns:\n        float: The Euclidean distance between the centers of the bounding boxes of the two TrackedObjects.\n    \"\"\"\n    # Get the bounding boxes from the Metadata of each TrackedObject\n    bbox1 = candidate.metadata.bbox\n    bbox2 = switcher.metadata.bbox\n\n    # Calculate the Euclidean distance between the centers of the bounding boxes\n    center1 = ((bbox1[0] + bbox1[2]) / 2, (bbox1[1] + bbox1[3]) / 2)\n    center2 = ((bbox2[0] + bbox2[2]) / 2, (bbox2[1] + bbox2[3]) / 2)\n    distance = np.sqrt((center1[0] - center2[0]) ** 2 + (center1[1] - center2[1]) ** 2)\n\n    return distance\n</code></pre>"},{"location":"reference/matcher/","title":"Matcher","text":""},{"location":"reference/matcher/#trackreid.matcher.Matcher","title":"<code> Matcher        </code>","text":"Source code in <code>trackreid/matcher.py</code> <pre><code>class Matcher:\n    def __init__(\n        self,\n        cost_function: Callable,\n        selection_function: Callable,\n        cost_function_threshold: Optional[Union[int, float]] = None,\n    ) -&gt; None:\n\"\"\"\n        Initializes the Matcher object with the provided cost function, selection function, and cost function threshold.\n\n        Args:\n            cost_function (Callable): A function that calculates the cost of matching two objects. This function should take two TrackedObject instances as input and return a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match.\n            selection_function (Callable): A function that determines whether two objects should be considered for matching. This function should take two TrackedObject instances as input and return a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered.\n            cost_function_threshold (Optional[Union[int, float]]): An optional threshold value for the cost function. If provided, any pair of objects with a matching cost greater than this threshold will not be considered for matching. If not provided, all selected pairs will be considered regardless of their matching cost.\n\n        Returns:\n            None\n        \"\"\"  # noqa: E501\n        self.cost_function = cost_function\n        self.selection_function = selection_function\n        self.cost_function_threshold = cost_function_threshold\n\n    def compute_cost_matrix(\n        self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n    ) -&gt; np.ndarray:\n\"\"\"Computes a cost matrix of size [M, N] between a list of M TrackedObjects candidates,\n        and a list of N TrackedObjects switchers.\n\n        Args:\n            candidates (List[TrackedObject]): list of candidates for matches.\n            switchers (List[TrackedObject]): list of objects to be matched.\n\n        Returns:\n            np.ndarray: cost to match each pair of objects.\n        \"\"\"\n        if not candidates or not switchers:\n            return np.array([])  # Return an empty array if either list is empty\n\n        # Create matrices with all combinations of candidates and switchers\n        candidates_matrix, switchers_matrix = np.meshgrid(candidates, switchers)\n\n        # Use np.vectorize to apply the scoring function to all combinations\n        cost_matrix = np.vectorize(self.cost_function)(candidates_matrix, switchers_matrix)\n\n        return cost_matrix\n\n    def compute_selection_matrix(\n        self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n    ) -&gt; np.ndarray:\n\"\"\"Computes a selection matrix of size [M, N] between a list of M TrackedObjects candidates,\n        and a list of N TrackedObjects switchers.\n\n        Args:\n            candidates (List[TrackedObject]): list of candidates for matches.\n            switchers (List[TrackedObject]): list of objects to be rematched.\n\n        Returns:\n            np.ndarray: cost each pair of objects be matched or not ?\n        \"\"\"\n        if not candidates or not switchers:\n            return np.array([])  # Return an empty array if either list is empty\n\n        # Create matrices with all combinations of candidates and switchers\n        candidates_matrix, switchers_matrix = np.meshgrid(candidates, switchers)\n\n        # Use np.vectorize to apply the scoring function to all combinations\n        selection_matrix = np.vectorize(self.selection_function)(\n            candidates_matrix, switchers_matrix\n        )\n\n        return selection_matrix\n\n    def match(\n        self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n    ) -&gt; List[Dict[TrackedObject, TrackedObject]]:\n\"\"\"Computes a dict of matching between objects in list candidates and objects in switchers.\n\n        Args:\n            candidates (List[TrackedObject]): list of candidates for matches.\n            switchers (List[TrackedObject]): list of objects to be matched.\n\n        Returns:\n            List[Dict[TrackedObject, TrackedObject]]: list of pairs of TrackedObjects\n            if there is a match.\n        \"\"\"\n        if not candidates or not switchers:\n            return []  # Return an empty array if either list is empty\n\n        cost_matrix = self.compute_cost_matrix(candidates, switchers)\n        selection_matrix = self.compute_selection_matrix(candidates, switchers)\n\n        # Set a elements values to be discard at DISALLOWED_MATCH value, large cost\n        cost_matrix[selection_matrix == 0] = reid_constants.MATCHES.DISALLOWED_MATCH\n        if self.cost_function_threshold is not None:\n            cost_matrix[\n                cost_matrix &gt; self.cost_function_threshold\n            ] = reid_constants.MATCHES.DISALLOWED_MATCH\n\n        matches = self.linear_assigment(cost_matrix, candidates=candidates, switchers=switchers)\n\n        return matches\n\n    @staticmethod\n    def linear_assigment(\n        cost_matrix: np.ndarray, candidates: List[TrackedObject], switchers: List[TrackedObject]\n    ) -&gt; List[Dict[TrackedObject, TrackedObject]]:\n\"\"\"\n        Performs linear assignment on the cost matrix to find the optimal match between candidates and switchers.\n\n        The function uses the Jonker-Volgenant algorithm to solve the linear assignment problem. The algorithm finds the\n        optimal assignment (minimum total cost) for the given cost matrix. The cost matrix is a 2D numpy array where\n        each cell represents the cost of assigning a candidate to a switcher.\n\n        Args:\n            cost_matrix (np.ndarray): A 2D array representing the cost of assigning each candidate to each switcher.\n            candidates (List[TrackedObject]): A list of candidate TrackedObjects for matching.\n            switchers (List[TrackedObject]): A list of switcher TrackedObjects to be matched.\n\n        Returns:\n            List[Dict[TrackedObject, TrackedObject]]: A list of dictionaries where each dictionary represents a match.\n            The key is a candidate and the value is the corresponding switcher.\n        \"\"\"\n        _, _, row_cols = lap.lapjv(\n            cost_matrix, extend_cost=True, cost_limit=reid_constants.MATCHES.DISALLOWED_MATCH - 0.1\n        )\n\n        matches = []\n        for candidate_idx, switcher_idx in enumerate(row_cols):\n            if switcher_idx &gt;= 0:\n                matches.append({candidates[candidate_idx]: switchers[switcher_idx]})\n\n        return matches\n</code></pre>"},{"location":"reference/matcher/#trackreid.matcher.Matcher.__init__","title":"<code>__init__(self, cost_function, selection_function, cost_function_threshold=None)</code>  <code>special</code>","text":"<p>Initializes the Matcher object with the provided cost function, selection function, and cost function threshold.</p> <p>Parameters:</p> Name Type Description Default <code>cost_function</code> <code>Callable</code> <p>A function that calculates the cost of matching two objects. This function should take two TrackedObject instances as input and return a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match.</p> required <code>selection_function</code> <code>Callable</code> <p>A function that determines whether two objects should be considered for matching. This function should take two TrackedObject instances as input and return a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered.</p> required <code>cost_function_threshold</code> <code>Optional[Union[int, float]]</code> <p>An optional threshold value for the cost function. If provided, any pair of objects with a matching cost greater than this threshold will not be considered for matching. If not provided, all selected pairs will be considered regardless of their matching cost.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>trackreid/matcher.py</code> <pre><code>def __init__(\n    self,\n    cost_function: Callable,\n    selection_function: Callable,\n    cost_function_threshold: Optional[Union[int, float]] = None,\n) -&gt; None:\n\"\"\"\n    Initializes the Matcher object with the provided cost function, selection function, and cost function threshold.\n\n    Args:\n        cost_function (Callable): A function that calculates the cost of matching two objects. This function should take two TrackedObject instances as input and return a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match.\n        selection_function (Callable): A function that determines whether two objects should be considered for matching. This function should take two TrackedObject instances as input and return a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered.\n        cost_function_threshold (Optional[Union[int, float]]): An optional threshold value for the cost function. If provided, any pair of objects with a matching cost greater than this threshold will not be considered for matching. If not provided, all selected pairs will be considered regardless of their matching cost.\n\n    Returns:\n        None\n    \"\"\"  # noqa: E501\n    self.cost_function = cost_function\n    self.selection_function = selection_function\n    self.cost_function_threshold = cost_function_threshold\n</code></pre>"},{"location":"reference/matcher/#trackreid.matcher.Matcher.compute_cost_matrix","title":"<code>compute_cost_matrix(self, candidates, switchers)</code>","text":"<p>Computes a cost matrix of size [M, N] between a list of M TrackedObjects candidates, and a list of N TrackedObjects switchers.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>List[TrackedObject]</code> <p>list of candidates for matches.</p> required <code>switchers</code> <code>List[TrackedObject]</code> <p>list of objects to be matched.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>cost to match each pair of objects.</p> Source code in <code>trackreid/matcher.py</code> <pre><code>def compute_cost_matrix(\n    self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n) -&gt; np.ndarray:\n\"\"\"Computes a cost matrix of size [M, N] between a list of M TrackedObjects candidates,\n    and a list of N TrackedObjects switchers.\n\n    Args:\n        candidates (List[TrackedObject]): list of candidates for matches.\n        switchers (List[TrackedObject]): list of objects to be matched.\n\n    Returns:\n        np.ndarray: cost to match each pair of objects.\n    \"\"\"\n    if not candidates or not switchers:\n        return np.array([])  # Return an empty array if either list is empty\n\n    # Create matrices with all combinations of candidates and switchers\n    candidates_matrix, switchers_matrix = np.meshgrid(candidates, switchers)\n\n    # Use np.vectorize to apply the scoring function to all combinations\n    cost_matrix = np.vectorize(self.cost_function)(candidates_matrix, switchers_matrix)\n\n    return cost_matrix\n</code></pre>"},{"location":"reference/matcher/#trackreid.matcher.Matcher.compute_selection_matrix","title":"<code>compute_selection_matrix(self, candidates, switchers)</code>","text":"<p>Computes a selection matrix of size [M, N] between a list of M TrackedObjects candidates, and a list of N TrackedObjects switchers.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>List[TrackedObject]</code> <p>list of candidates for matches.</p> required <code>switchers</code> <code>List[TrackedObject]</code> <p>list of objects to be rematched.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>cost each pair of objects be matched or not ?</p> Source code in <code>trackreid/matcher.py</code> <pre><code>def compute_selection_matrix(\n    self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n) -&gt; np.ndarray:\n\"\"\"Computes a selection matrix of size [M, N] between a list of M TrackedObjects candidates,\n    and a list of N TrackedObjects switchers.\n\n    Args:\n        candidates (List[TrackedObject]): list of candidates for matches.\n        switchers (List[TrackedObject]): list of objects to be rematched.\n\n    Returns:\n        np.ndarray: cost each pair of objects be matched or not ?\n    \"\"\"\n    if not candidates or not switchers:\n        return np.array([])  # Return an empty array if either list is empty\n\n    # Create matrices with all combinations of candidates and switchers\n    candidates_matrix, switchers_matrix = np.meshgrid(candidates, switchers)\n\n    # Use np.vectorize to apply the scoring function to all combinations\n    selection_matrix = np.vectorize(self.selection_function)(\n        candidates_matrix, switchers_matrix\n    )\n\n    return selection_matrix\n</code></pre>"},{"location":"reference/matcher/#trackreid.matcher.Matcher.linear_assigment","title":"<code>linear_assigment(cost_matrix, candidates, switchers)</code>  <code>staticmethod</code>","text":"<p>Performs linear assignment on the cost matrix to find the optimal match between candidates and switchers.</p> <p>The function uses the Jonker-Volgenant algorithm to solve the linear assignment problem. The algorithm finds the optimal assignment (minimum total cost) for the given cost matrix. The cost matrix is a 2D numpy array where each cell represents the cost of assigning a candidate to a switcher.</p> <p>Parameters:</p> Name Type Description Default <code>cost_matrix</code> <code>np.ndarray</code> <p>A 2D array representing the cost of assigning each candidate to each switcher.</p> required <code>candidates</code> <code>List[TrackedObject]</code> <p>A list of candidate TrackedObjects for matching.</p> required <code>switchers</code> <code>List[TrackedObject]</code> <p>A list of switcher TrackedObjects to be matched.</p> required <p>Returns:</p> Type Description <code>List[Dict[TrackedObject, TrackedObject]]</code> <p>A list of dictionaries where each dictionary represents a match. The key is a candidate and the value is the corresponding switcher.</p> Source code in <code>trackreid/matcher.py</code> <pre><code>@staticmethod\ndef linear_assigment(\n    cost_matrix: np.ndarray, candidates: List[TrackedObject], switchers: List[TrackedObject]\n) -&gt; List[Dict[TrackedObject, TrackedObject]]:\n\"\"\"\n    Performs linear assignment on the cost matrix to find the optimal match between candidates and switchers.\n\n    The function uses the Jonker-Volgenant algorithm to solve the linear assignment problem. The algorithm finds the\n    optimal assignment (minimum total cost) for the given cost matrix. The cost matrix is a 2D numpy array where\n    each cell represents the cost of assigning a candidate to a switcher.\n\n    Args:\n        cost_matrix (np.ndarray): A 2D array representing the cost of assigning each candidate to each switcher.\n        candidates (List[TrackedObject]): A list of candidate TrackedObjects for matching.\n        switchers (List[TrackedObject]): A list of switcher TrackedObjects to be matched.\n\n    Returns:\n        List[Dict[TrackedObject, TrackedObject]]: A list of dictionaries where each dictionary represents a match.\n        The key is a candidate and the value is the corresponding switcher.\n    \"\"\"\n    _, _, row_cols = lap.lapjv(\n        cost_matrix, extend_cost=True, cost_limit=reid_constants.MATCHES.DISALLOWED_MATCH - 0.1\n    )\n\n    matches = []\n    for candidate_idx, switcher_idx in enumerate(row_cols):\n        if switcher_idx &gt;= 0:\n            matches.append({candidates[candidate_idx]: switchers[switcher_idx]})\n\n    return matches\n</code></pre>"},{"location":"reference/matcher/#trackreid.matcher.Matcher.match","title":"<code>match(self, candidates, switchers)</code>","text":"<p>Computes a dict of matching between objects in list candidates and objects in switchers.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>List[TrackedObject]</code> <p>list of candidates for matches.</p> required <code>switchers</code> <code>List[TrackedObject]</code> <p>list of objects to be matched.</p> required <p>Returns:</p> Type Description <code>List[Dict[TrackedObject, TrackedObject]]</code> <p>list of pairs of TrackedObjects if there is a match.</p> Source code in <code>trackreid/matcher.py</code> <pre><code>def match(\n    self, candidates: List[TrackedObject], switchers: List[TrackedObject]\n) -&gt; List[Dict[TrackedObject, TrackedObject]]:\n\"\"\"Computes a dict of matching between objects in list candidates and objects in switchers.\n\n    Args:\n        candidates (List[TrackedObject]): list of candidates for matches.\n        switchers (List[TrackedObject]): list of objects to be matched.\n\n    Returns:\n        List[Dict[TrackedObject, TrackedObject]]: list of pairs of TrackedObjects\n        if there is a match.\n    \"\"\"\n    if not candidates or not switchers:\n        return []  # Return an empty array if either list is empty\n\n    cost_matrix = self.compute_cost_matrix(candidates, switchers)\n    selection_matrix = self.compute_selection_matrix(candidates, switchers)\n\n    # Set a elements values to be discard at DISALLOWED_MATCH value, large cost\n    cost_matrix[selection_matrix == 0] = reid_constants.MATCHES.DISALLOWED_MATCH\n    if self.cost_function_threshold is not None:\n        cost_matrix[\n            cost_matrix &gt; self.cost_function_threshold\n        ] = reid_constants.MATCHES.DISALLOWED_MATCH\n\n    matches = self.linear_assigment(cost_matrix, candidates=candidates, switchers=switchers)\n\n    return matches\n</code></pre>"},{"location":"reference/reid_processor/","title":"Reid processor","text":""},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor","title":"<code> ReidProcessor        </code>","text":"<p>The ReidProcessor class is designed to correct the results of tracking algorithms by reconciling and reassigning lost or misidentified IDs. This ensures a consistent and accurate tracking of objects over time.</p> <p>All input data should be of numeric type, either integers or floats. Here's an example of how the input data should look like based on the schema:</p> bbox (0-3) object_id (4) category (5) confidence (6) 50, 60, 120, 80 1 1 0.91 50, 60, 120, 80 2 0 0.54 <p>Each row represents a detected object. The first four columns represent the bounding box coordinates (x, y, width, height), the fifth column represents the object ID assigned by the tracker, the sixth column represents the category of the detected object, and the seventh column represents the confidence score of the detection.</p> <p>You can use ReidProcessor.print_input_data_requirements() for more insight.</p> <p>Here's an example of how the output data looks like based on the schema:</p> frame_id (0) object_id (1) category (2) bbox (3-6) confidence (7) mean_confidence (8) tracker_id (9) 1 1 1 50, 60, 120, 80 0.91 0.85 1 2 2 0 50, 60, 120, 80 0.54 0.60 2 <p>You can use ReidProcessor.print_output_data_format_information() for more insight.</p> <p>Parameters:</p> Name Type Description Default <code>filter_confidence_threshold</code> <code>float</code> <p>Confidence threshold for the filter. The filter will only consider tracked objects that have a mean confidence score during the all transaction above this threshold.</p> required <code>filter_time_threshold</code> <code>int</code> <p>Time threshold for the filter. The filter will only consider tracked objects that have been seen for a number of frames above this threshold.</p> required <code>max_frames_to_rematch</code> <code>int</code> <p>Maximum number of frames to rematch. If a switcher is lost for a number of frames greater than this value, it will be flagged as lost forever.</p> required <code>max_attempt_to_match</code> <code>int</code> <p>Maximum number of attempts to match a candidate. If a candidate has not been rematched despite a number of attempts equal to this value, it will be flagged as a stable object.</p> required <code>selection_function</code> <code>Callable</code> <p>A function that determines whether two objects should be considered for matching. The selection function should take two TrackedObject instances as input and return a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered.</p> <code>&lt;function select_by_category at 0x7f39bc3fdf80&gt;</code> <code>cost_function</code> <code>Callable</code> <p>A function that calculates the cost of matching two objects. The cost function should take two TrackedObject instances as input and return a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match.</p> <code>&lt;function bounding_box_distance at 0x7f39bc3ede40&gt;</code> <code>cost_function_threshold</code> <code>Optional[Union[int, float]]</code> <p>An maximal threshold value for the cost function. If provided, any pair of objects with a matching cost greater than this threshold will not be considered for matching. If not provided, all selected pairs will be considered regardless of their matching cost.</p> <code>None</code> <code>save_to_txt</code> <code>bool</code> <p>A flag indicating whether to save the results to a text file. If set to True, the results will be saved to a text file specified by the file_path parameter.</p> <code>False</code> <code>file_path</code> <code>str</code> <p>The path to the text file where the results will be saved if save_to_txt is set to True.</p> <code>'tracks.txt'</code> Source code in <code>trackreid/reid_processor.py</code> <pre><code>class ReidProcessor:\n\"\"\"\n    The ReidProcessor class is designed to correct the results of tracking algorithms by reconciling and reassigning\n    lost or misidentified IDs. This ensures a consistent and accurate tracking of objects over time.\n\n    All input data should be of numeric type, either integers or floats.\n    Here's an example of how the input data should look like based on the schema:\n\n    | bbox (0-3)      | object_id (4) | category (5) | confidence (6) |\n    |-----------------|---------------|--------------|----------------|\n    | 50, 60, 120, 80 |       1       |       1      |       0.91     |\n    | 50, 60, 120, 80 |       2       |       0      |       0.54     |\n\n    Each row represents a detected object. The first four columns represent the bounding box coordinates\n    (x, y, width, height), the fifth column represents the object ID assigned by the tracker,\n    the sixth column represents the category of the detected object, and the seventh column represents\n    the confidence score of the detection.\n\n    You can use ReidProcessor.print_input_data_requirements() for more insight.\n\n    Here's an example of how the output data looks like based on the schema:\n\n    | frame_id (0) | object_id (1) | category (2) | bbox (3-6)      | confidence (7) | mean_confidence (8) | tracker_id (9) |\n    |--------------|---------------|--------------|-----------------|----------------|---------------------|----------------|\n    | 1            | 1             | 1            | 50, 60, 120, 80 | 0.91           | 0.85                | 1              |\n    | 2            | 2             | 0            | 50, 60, 120, 80 | 0.54           | 0.60                | 2              |\n\n    You can use ReidProcessor.print_output_data_format_information() for more insight.\n\n\n    Args:\n        filter_confidence_threshold (float): Confidence threshold for the filter. The filter will only consider tracked objects that have a mean confidence score during the all transaction above this threshold.\n\n        filter_time_threshold (int): Time threshold for the filter. The filter will only consider tracked objects that have been seen for a number of frames above this threshold.\n\n        max_frames_to_rematch (int): Maximum number of frames to rematch. If a switcher is lost for a number of frames greater than this value, it will be flagged as lost forever.\n\n        max_attempt_to_match (int): Maximum number of attempts to match a candidate. If a candidate has not been rematched despite a number of attempts equal to this value, it will be flagged as a stable object.\n\n        selection_function (Callable): A function that determines whether two objects should be considered for matching. The selection function should take two TrackedObject instances as input and return a binary value (0 or 1). A return value of 1 indicates that the pair should be considered for matching, while a return value of 0 indicates that the pair should not be considered.\n\n        cost_function (Callable): A function that calculates the cost of matching two objects. The cost function should take two TrackedObject instances as input and return a numerical value representing the cost of matching these two objects. A lower cost indicates a higher likelihood of a match.\n\n        cost_function_threshold (Optional[Union[int, float]]): An maximal threshold value for the cost function. If provided, any pair of objects with a matching cost greater than this threshold will not be considered for matching. If not provided, all selected pairs will be considered regardless of their matching cost.\\n\n\n        save_to_txt (bool): A flag indicating whether to save the results to a text file. If set to True, the results will be saved to a text file specified by the file_path parameter.\n\n        file_path (str): The path to the text file where the results will be saved if save_to_txt is set to True.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        filter_confidence_threshold: float,\n        filter_time_threshold: int,\n        max_frames_to_rematch: int,\n        max_attempt_to_match: int,\n        selection_function: Callable = select_by_category,\n        cost_function: Callable = bounding_box_distance,\n        cost_function_threshold: Optional[Union[int, float]] = None,\n        save_to_txt: bool = False,\n        file_path: str = \"tracks.txt\",\n    ) -&gt; None:\n        self.matcher = Matcher(\n            cost_function=cost_function,\n            selection_function=selection_function,\n            cost_function_threshold=cost_function_threshold,\n        )\n\n        self.tracked_filter = TrackedObjectFilter(\n            confidence_threshold=filter_confidence_threshold,\n            frames_seen_threshold=filter_time_threshold,\n        )\n\n        self.all_tracked_objects: List[TrackedObject] = []\n        self.last_frame_tracked_objects: Set[TrackedObject] = set()\n\n        self.max_frames_to_rematch = max_frames_to_rematch\n        self.max_attempt_to_match = max_attempt_to_match\n\n        self.frame_id = 0\n        self.nb_output_cols = get_nb_output_cols(output_positions=output_data_positions)\n\n        self.save_to_txt = save_to_txt\n        self.file_path = file_path\n\n    def reset(self) -&gt; None:\n\"\"\"\n        Resets the ReID processor state for a new processing sequence.\n\n        This method resets the frame counter to zero and clears all tracked objects\n        and the last frame's tracked objects from memory, preparing the processor\n        for a new sequence of frames.\n        \"\"\"\n        self.frame_id = 0\n        self.all_tracked_objects: List[TrackedObject] = []\n        self.last_frame_tracked_objects: Set[TrackedObject] = set()\n\n    def set_file_path(self, new_file_path: str) -&gt; None:\n\"\"\"\n        Sets a new file path for saving txt data.\n\n        Args:\n            new_file_path (str): The new file path.\n        \"\"\"\n        self.file_path = new_file_path\n\n    @property\n    def nb_corrections(self) -&gt; int:\n\"\"\"\n        Calculates and returns the total number of corrections made across all tracked objects.\n\n        Returns:\n            int: Total number of corrections.\n        \"\"\"\n        nb_corrections = 0\n        for obj in self.all_tracked_objects:\n            nb_corrections += obj.nb_corrections\n        return nb_corrections\n\n    @property\n    def nb_tracker_ids(self) -&gt; int:\n\"\"\"\n        Calculates and returns the total number of tracker IDs across all tracked objects.\n\n        Returns:\n            int: Total number of tracker IDs.\n        \"\"\"\n        tracker_ids = 0\n        for obj in self.all_tracked_objects:\n            tracker_ids += obj.nb_ids\n        return tracker_ids\n\n    @property\n    def corrected_objects(self) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Returns a list of tracked objects that have been corrected.\n\n        Returns:\n            List[TrackedObject]: List of corrected tracked objects.\n        \"\"\"\n        return [obj for obj in self.all_tracked_objects if obj.nb_corrections]\n\n    @property\n    def seen_objects(self) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Returns a list of tracked objects that have been seen, excluding those in the\n        states TRACKER_OUTPUT and FILTERED_OUTPUT.\n\n        Returns:\n            List[TrackedObject]: List of seen tracked objects.\n        \"\"\"\n        return filter_objects_by_state(\n            tracked_objects=self.all_tracked_objects,\n            states=[reid_constants.STATES.TRACKER_OUTPUT, reid_constants.STATES.FILTERED_OUTPUT],\n            exclusion=True,\n        )\n\n    @property\n    def mean_nb_corrections(self) -&gt; float:\n\"\"\"\n        Calculates and returns the mean number of corrections across all tracked objects.\n\n        Returns:\n            float: Mean number of corrections.\n        \"\"\"\n        if len(self.all_tracked_objects):\n            return self.nb_corrections / len(self.all_tracked_objects)\n        else:\n            return 0\n\n    def update(self, tracker_output: np.ndarray, frame_id: int) -&gt; np.ndarray:\n\"\"\"\n        Processes the tracker output and updates internal states.\n\n        All input data should be of numeric type, either integers or floats.\n        Here's an example of how the input data should look like based on the schema:\n\n        | bbox (0-3)      | object_id (4) | category (5) | confidence (6) |\n        |-----------------|---------------|--------------|----------------|\n        | 50, 60, 120, 80 |       1       |       1      |       0.91     |\n        | 50, 60, 120, 80 |       2       |       0      |       0.54     |\n\n        Each row represents a detected object. The first four columns represent the bounding box coordinates\n        (x, y, width, height), the fifth column represents the object ID assigned by the tracker,\n        the sixth column represents the category of the detected object, and the seventh column represents\n        the confidence score of the detection.\n\n        You can use ReidProcessor.print_input_data_requirements() for more insight.\n\n        Here's an example of how the output data looks like based on the schema:\n\n        | frame_id (0) | object_id (1) | category (2) | bbox (3-6)      | confidence (7) | mean_confidence (8) | tracker_id (9) |\n        |--------------|---------------|--------------|-----------------|----------------|---------------------|----------------|\n        | 1            | 1             | 1            | 50, 60, 120, 80 | 0.91           | 0.85                | 1              |\n        | 2            | 2             | 0            | 50, 60, 120, 80 | 0.54           | 0.60                | 2              |\n\n        You can use ReidProcessor.print_output_data_format_information() for more insight.\n\n        Args:\n            tracker_output (np.ndarray): The tracker output.\n            frame_id (int): The frame id.\n\n        Returns:\n            np.ndarray: The processed output.\n        \"\"\"  # noqa: E501\n        if tracker_output.size:  # empty tracking\n            self.all_tracked_objects, current_tracker_ids = self._preprocess(\n                tracker_output=tracker_output, frame_id=frame_id\n            )\n            self._perform_reid_process(current_tracker_ids=current_tracker_ids)\n            reid_output = self._postprocess(current_tracker_ids=current_tracker_ids)\n\n        else:\n            reid_output = tracker_output\n\n        if self.save_to_txt:\n            self._save_results_to_txt(file_path=self.file_path, reid_output=reid_output)\n\n        return reid_output\n\n    def _preprocess(self, tracker_output: np.ndarray, frame_id: int) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Preprocesses the tracker output.\n\n        Args:\n            tracker_output (np.ndarray): The tracker output.\n            frame_id (int): The frame id.\n\n        Returns:\n            List[\"TrackedObject\"]: The preprocessed output.\n        \"\"\"\n        reshaped_tracker_output = reshape_tracker_result(tracker_output=tracker_output)\n        current_tracker_ids = list(reshaped_tracker_output[:, input_data_positions.object_id])\n\n        self.all_tracked_objects = self._update_tracked_objects(\n            tracker_output=reshaped_tracker_output, frame_id=frame_id\n        )\n        self.all_tracked_objects = self._apply_filtering()\n        return self.all_tracked_objects, current_tracker_ids\n\n    def _update_tracked_objects(\n        self, tracker_output: np.ndarray, frame_id: int\n    ) -&gt; List[TrackedObject]:\n\"\"\"\n        Updates the tracked objects.\n\n        Args:\n            tracker_output (np.ndarray): The tracker output.\n            frame_id (int): The frame id.\n\n        Returns:\n            List[TrackedObject]: The updated tracked objects.\n        \"\"\"\n        self.frame_id = frame_id\n        for object_id, data_line in zip(\n            tracker_output[:, input_data_positions.object_id], tracker_output\n        ):\n            if object_id not in self.all_tracked_objects:\n                new_tracked_object = TrackedObject(\n                    object_ids=object_id,\n                    state=reid_constants.STATES.TRACKER_OUTPUT,\n                    frame_id=frame_id,\n                    metadata=data_line,\n                )\n                self.all_tracked_objects.append(new_tracked_object)\n            else:\n                self.all_tracked_objects[self.all_tracked_objects.index(object_id)].update_metadata(\n                    data_line, frame_id=frame_id\n                )\n\n        return self.all_tracked_objects\n\n    def _get_current_frame_tracked_objects(\n        self, current_tracker_ids: Set[Union[int, float]]\n    ) -&gt; Set[Union[int, float]]:\n\"\"\"\n        Retrieves the tracked objects for the current frame.\n\n        Args:\n            current_tracker_ids (Set[Union[int, float]]): The set of current tracker IDs.\n\n        Returns:\n            Set[Union[int, float]]: The set of tracked objects for the current frame.\n        \"\"\"\n        tracked_objects = filter_objects_by_state(\n            self.all_tracked_objects, states=reid_constants.STATES.TRACKER_OUTPUT, exclusion=True\n        )\n\n        current_frame_tracked_objects = set(\n            [tracked_id for tracked_id in tracked_objects if tracked_id in current_tracker_ids]\n        )\n\n        return current_frame_tracked_objects\n\n    def _apply_filtering(self) -&gt; List[TrackedObject]:\n\"\"\"\n        Applies filtering to the tracked objects.\n\n        Returns:\n            List[TrackedObject]: The filtered tracked objects.\n        \"\"\"\n        for tracked_object in self.all_tracked_objects:\n            self.tracked_filter.update(tracked_object)\n\n        return self.all_tracked_objects\n\n    def _perform_reid_process(self, current_tracker_ids: List[Union[int, float]]) -&gt; None:\n\"\"\"\n        Performs the re-identification process on tracked objects.\n\n        This method is responsible for managing the state of tracked objects and identifying potential\n        candidates for re-identification. It follows these steps:\n\n        1.  _correct_reid_chains: Corrects the re-identification chains of all tracked objects\n        based on the current tracker IDs. This avoids potential duplicates.\n        2.  _update_switchers_states: Updates the states of switchers (objects that have switched IDs)\n        based on the current frame's tracked objects, the maximum number of frames to rematch, and the current frame ID.\n        3.  _update_candidates_states: Updates the states of candidate objects (potential matches for re-identification)\n        based on the maximum number of attempts to match and the current frame ID.\n        4.  _identify_switchers: Identifies switchers based on the current and last frame's tracked objects and\n        updates the state of all tracked objects accordingly.\n        5.  _identify_candidates: Identifies candidates for re-identification and updates the state of all\n        tracked objects accordingly.\n        6.  match: Matches candidates with switchers using Jonker-Volgenant algorithm.\n        7.  _process_matches: Processes the matches and updates the state of all tracked objects accordingly.\n\n        Args:\n            current_tracker_ids (List[Union[int, float]]): The current tracker IDs.\n        \"\"\"\n\n        self.all_tracked_objects = self._correct_reid_chains(\n            all_tracked_objects=self.all_tracked_objects, current_tracker_ids=current_tracker_ids\n        )\n\n        current_frame_tracked_objects = self._get_current_frame_tracked_objects(\n            current_tracker_ids=current_tracker_ids\n        )\n\n        self.all_tracked_objects = self._update_switchers_states(\n            all_tracked_objects=self.all_tracked_objects,\n            current_frame_tracked_objects=current_frame_tracked_objects,\n            max_frames_to_rematch=self.max_frames_to_rematch,\n            frame_id=self.frame_id,\n        )\n\n        self.all_tracked_objects = self._update_candidates_states(\n            all_tracked_objects=self.all_tracked_objects,\n            max_attempt_to_match=self.max_attempt_to_match,\n            frame_id=self.frame_id,\n        )\n\n        self.all_tracked_objects = self._identify_switchers(\n            current_frame_tracked_objects=current_frame_tracked_objects,\n            last_frame_tracked_objects=self.last_frame_tracked_objects,\n            all_tracked_objects=self.all_tracked_objects,\n        )\n\n        self.all_tracked_objects = self._identify_candidates(\n            all_tracked_objects=self.all_tracked_objects\n        )\n\n        candidates = filter_objects_by_state(\n            self.all_tracked_objects, states=reid_constants.STATES.CANDIDATE, exclusion=False\n        )\n        switchers = filter_objects_by_state(\n            self.all_tracked_objects, states=reid_constants.STATES.SWITCHER, exclusion=False\n        )\n\n        matches = self.matcher.match(candidates, switchers)\n\n        self.all_tracked_objects = self._process_matches(\n            all_tracked_objects=self.all_tracked_objects,\n            matches=matches,\n        )\n\n        current_frame_tracked_objects = self._get_current_frame_tracked_objects(\n            current_tracker_ids=current_tracker_ids\n        )\n\n        self.last_frame_tracked_objects = current_frame_tracked_objects.copy()\n\n    @staticmethod\n    def _identify_switchers(\n        all_tracked_objects: List[\"TrackedObject\"],\n        current_frame_tracked_objects: Set[\"TrackedObject\"],\n        last_frame_tracked_objects: Set[\"TrackedObject\"],\n    ) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Identifies switchers in the list of all tracked objects, and\n        update their states. A switcher is an object that is lost, and probably\n        needs to be rematched.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n            current_frame_tracked_objects (Set[\"TrackedObject\"]): Set of currently tracked objects.\n            last_frame_tracked_objects Set[\"TrackedObject\"]: Set of last timestep tracked objects.\n\n        Returns:\n            List[\"TrackedObject\"]: Updated list of all tracked objects after state changes.\n        \"\"\"\n        lost_objects = last_frame_tracked_objects - current_frame_tracked_objects\n\n        for tracked_object in all_tracked_objects:\n            if tracked_object in lost_objects:\n                tracked_object.state = reid_constants.STATES.SWITCHER\n\n        return all_tracked_objects\n\n    @staticmethod\n    def _identify_candidates(all_tracked_objects: List[\"TrackedObject\"]) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Identifies candidates in the list of all tracked objects, and\n        update their states. A candidate is an object that was never seen before and\n        that probably needs to be rematched.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n\n        Returns:\n            List[\"TrackedObject\"]: Updated list of all tracked objects after state changes.\n        \"\"\"\n        tracked_objects = filter_objects_by_state(\n            all_tracked_objects, states=reid_constants.STATES.TRACKER_OUTPUT, exclusion=True\n        )\n        for current_object in tracked_objects:\n            if current_object.state == reid_constants.STATES.FILTERED_OUTPUT:\n                current_object.state = reid_constants.STATES.CANDIDATE\n        return all_tracked_objects\n\n    @staticmethod\n    def _correct_reid_chains(\n        all_tracked_objects: List[\"TrackedObject\"],\n        current_tracker_ids: List[Union[int, float]],\n    ) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Corrects the reid chains to prevent duplicates when an object reappears with a corrected id.\n        For instance, if an object has a reid chain [1, 3, 6, 7], only the id 7 should be in the tracker's output.\n        If another id from the chain (e.g., 3) is in the tracker's output, the reid chain is split into two:\n        [1, 3] and [6, 7]. The first object's state is set to stable as 3 is in the current tracker output,\n        and a new object with reid chain [6, 7] is created.\n        The new object's state can be:\n            - stable, if the tracker output is in the new reid chain\n            - switcher, if not\n            - nothing, if this is a singleton object, in which case the reid process is performed automatically.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n            current_tracker_ids (List[Union[int, float]]): The current tracker IDs.\n\n        Returns:\n            List[\"TrackedObject\"]: The corrected tracked objects.\n        \"\"\"\n        top_list_correction = get_top_list_correction(all_tracked_objects)\n        to_correct = set(current_tracker_ids) - set(top_list_correction)\n\n        for current_object in to_correct:\n            tracked_id = all_tracked_objects[all_tracked_objects.index(current_object)]\n            all_tracked_objects.remove(tracked_id)\n            new_object, tracked_id = tracked_id.cut(current_object)\n\n            tracked_id.state = reid_constants.STATES.STABLE\n            all_tracked_objects.append(tracked_id)\n\n            if new_object in current_tracker_ids:\n                new_object.state = reid_constants.STATES.CANDIDATE\n                all_tracked_objects.append(new_object)\n\n            elif new_object.nb_corrections &gt; 1:\n                new_object.state = reid_constants.STATES.SWITCHER\n                all_tracked_objects.append(new_object)\n\n        return all_tracked_objects\n\n    @staticmethod\n    def _process_matches(\n        all_tracked_objects: List[\"TrackedObject\"],\n        matches: Dict[\"TrackedObject\", \"TrackedObject\"],\n    ) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Processes the matches.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n            matches (Dict[\"TrackedObject\", \"TrackedObject\"]): The matches.\n\n        Returns:\n            List[\"TrackedObject\"]: The processed tracked objects.\n        \"\"\"\n        for match in matches:\n            candidate_match, switcher_match = match.popitem()\n            switcher_match.merge(candidate_match)\n            switcher_match.state = reid_constants.STATES.STABLE\n            all_tracked_objects.remove(candidate_match)\n\n        return all_tracked_objects\n\n    @staticmethod\n    def _update_switchers_states(\n        all_tracked_objects: List[\"TrackedObject\"],\n        current_frame_tracked_objects: Set[\"TrackedObject\"],\n        max_frames_to_rematch: int,\n        frame_id: int,\n    ) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Updates the state of switchers in the list of all tracked objects:\n            - If a switcher is lost for too long, it will be flaged as lost forever\n            - If a switcher reapears in the tracking output, it will be flaged as\n            a stable object.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n            current_frame_tracked_objects (Set[\"TrackedObject\"]): Set of currently tracked objects.\n            max_frames_to_rematch (int): Maximum number of frames to rematch.\n            frame_id (int): Current frame id.\n\n        Returns:\n            List[\"TrackedObject\"]: Updated list of all tracked objects after state changes.\n        \"\"\"\n        switchers = filter_objects_by_state(\n            all_tracked_objects, reid_constants.STATES.SWITCHER, exclusion=False\n        )\n        switchers_to_drop = set(switchers).intersection(current_frame_tracked_objects)\n\n        for switcher in switchers:\n            if switcher in switchers_to_drop:\n                switcher.state = reid_constants.STATES.STABLE\n            elif switcher.get_nb_frames_since_last_appearance(frame_id) &gt; max_frames_to_rematch:\n                switcher.state = reid_constants.STATES.LOST_FOREVER\n\n        return all_tracked_objects\n\n    @staticmethod\n    def _update_candidates_states(\n        all_tracked_objects: List[\"TrackedObject\"], max_attempt_to_match: int, frame_id: int\n    ) -&gt; List[\"TrackedObject\"]:\n\"\"\"\n        Updates the state of candidates in the list of all tracked objects.\n        If a candidate has not been rematched despite max_attempt_to_match attempts,\n        if will be flaged as a stable object.\n\n        Args:\n            all_tracked_objects (List[\"TrackedObject\"]): List of all objects being tracked.\n            max_attempt_to_match (int): Maximum attempt to match a candidate.\n            frame_id (int): Current frame id.\n\n        Returns:\n            List[\"TrackedObject\"]: Updated list of all tracked objects after state changes.\n        \"\"\"\n        candidates = filter_objects_by_state(\n            tracked_objects=all_tracked_objects,\n            states=reid_constants.STATES.CANDIDATE,\n            exclusion=False,\n        )\n\n        for candidate in candidates:\n            if candidate.get_age(frame_id) &gt;= max_attempt_to_match:\n                candidate.state = reid_constants.STATES.STABLE\n        return all_tracked_objects\n\n    def _postprocess(\n        self,\n        current_tracker_ids: List[Union[int, float]],\n    ) -&gt; np.ndarray:\n\"\"\"\n        Postprocesses the current tracker IDs.\n        It selects the stable TrackedObjects, and formats their datas in the output\n        to match requirements.\n\n        Args:\n            current_tracker_ids (List[Union[int, float]]): The current tracker IDs.\n\n        Returns:\n            np.ndarray: The postprocessed output.\n        \"\"\"\n        stable_objects = [\n            obj\n            for obj in self.all_tracked_objects\n            if obj.get_state() == reid_constants.STATES.STABLE and obj in current_tracker_ids\n        ]\n\n        reid_output = np.zeros((len(stable_objects), self.nb_output_cols))\n\n        for idx, stable_object in enumerate(stable_objects):\n            for required_variable in output_data_positions.model_json_schema()[\"properties\"].keys():\n                output = (\n                    self.frame_id\n                    if required_variable == \"frame_id\"\n                    else getattr(stable_object, required_variable, None)\n                )\n                if output is None:\n                    raise NameError(\n                        f\"Attribute {required_variable} not in TrackedObject. Check your required output names.\"\n                    )\n                reid_output[idx, getattr(output_data_positions, required_variable)] = output\n\n        return reid_output\n\n    def _save_results_to_txt(self, file_path: str, reid_output: np.ndarray) -&gt; None:\n\"\"\"\n        Saves the reid_output to a txt file.\n\n        Args:\n            file_path (str): The path to the txt file.\n            reid_output (np.ndarray): The output of _post_process.\n        \"\"\"\n        with open(file_path, \"a\") as f:  # noqa: PTH123\n            for row in reid_output:\n                line = \" \".join(\n                    str(int(val)) if val.is_integer() else \"{:.6f}\".format(val) for val in row\n                )\n                f.write(line + \"\\n\")\n\n    def to_dict(self) -&gt; Dict:\n\"\"\"\n        Converts the tracked objects to a dictionary.\n\n        Returns:\n            Dict: The dictionary representation of the tracked objects.\n        \"\"\"\n        data = dict()\n        for tracked_object in self.all_tracked_objects:\n            data[tracked_object.object_id] = tracked_object.to_dict()\n        return data\n\n    @staticmethod\n    def print_input_data_format_requirements():\n\"\"\"\n\n        Prints the input data format requirements.\n\n        All input data should be of numeric type, either integers or floats.\n        Here's an example of how the input data should look like based on the schema:\n\n        |    bbox (0-3)   | object_id (4) | category (5) | confidence (6) |\n        |-----------------|---------------|--------------|----------------|\n        | 50, 60, 120, 80 |       1       |       1      |       0.91     |\n        | 50, 60, 120, 80 |       2       |       0      |       0.54     |\n\n        Each row represents a detected object. The first four columns represent the bounding box coordinates\n        (x, y, width, height), the fifth column represents the object ID assigned by the tracker,\n        the sixth column represents the category of the detected object, and the seventh column represents\n        the confidence score of the detection.\n        \"\"\"\n        input_schema = input_data_positions.model_json_schema()\n\n        print(\"Input Data Format Requirements:\")\n        for name, properties in input_schema[\"properties\"].items():\n            print(\"-\" * 50)\n            print(f\"{name}: {properties['description']}\")\n            print(\n                f\"{name} (position of {name} in the input array must be): {properties['default']}\"\n            )\n\n    @staticmethod\n    def print_output_data_format_information():\n\"\"\"\n        Prints the output data format information.\n\n        Here's an example of how the output data looks like based on the schema:\n\n        | frame_id (0) | object_id (1) | category (2) | bbox (3-6) | confidence (7) | mean_confidence (8) | tracker_id (9) |\n        |--------------|---------------|--------------|------------|----------------|-------------------|------------------|\n        | 1            | 1             | 1            | 50,60,120,80 | 0.91         | 0.85              | 1                |\n        | 2            | 2             | 0            | 50,60,120,80 | 0.54         | 0.60              | 2                |\n\n        \"\"\"  # noqa: E501\n        output_schema = output_data_positions.model_json_schema()\n\n        print(\"\\nOutput Data Format:\")\n        for name, properties in output_schema[\"properties\"].items():\n            print(\"-\" * 50)\n            print(f\"{name}: {properties['description']}\")\n            print(\n                f\"{name} (position of {name} in the output array will be): {properties['default']}\"\n            )\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.corrected_objects","title":"<code>corrected_objects: List['TrackedObject']</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns a list of tracked objects that have been corrected.</p> <p>Returns:</p> Type Description <code>List[TrackedObject]</code> <p>List of corrected tracked objects.</p>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.mean_nb_corrections","title":"<code>mean_nb_corrections: float</code>  <code>property</code> <code>readonly</code>","text":"<p>Calculates and returns the mean number of corrections across all tracked objects.</p> <p>Returns:</p> Type Description <code>float</code> <p>Mean number of corrections.</p>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.nb_corrections","title":"<code>nb_corrections: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Calculates and returns the total number of corrections made across all tracked objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of corrections.</p>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.nb_tracker_ids","title":"<code>nb_tracker_ids: int</code>  <code>property</code> <code>readonly</code>","text":"<p>Calculates and returns the total number of tracker IDs across all tracked objects.</p> <p>Returns:</p> Type Description <code>int</code> <p>Total number of tracker IDs.</p>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.seen_objects","title":"<code>seen_objects: List['TrackedObject']</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns a list of tracked objects that have been seen, excluding those in the states TRACKER_OUTPUT and FILTERED_OUTPUT.</p> <p>Returns:</p> Type Description <code>List[TrackedObject]</code> <p>List of seen tracked objects.</p>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.print_input_data_format_requirements","title":"<code>print_input_data_format_requirements()</code>  <code>staticmethod</code>","text":"<p>Prints the input data format requirements.</p> <p>All input data should be of numeric type, either integers or floats. Here's an example of how the input data should look like based on the schema:</p> bbox (0-3) object_id (4) category (5) confidence (6) 50, 60, 120, 80 1 1 0.91 50, 60, 120, 80 2 0 0.54 <p>Each row represents a detected object. The first four columns represent the bounding box coordinates (x, y, width, height), the fifth column represents the object ID assigned by the tracker, the sixth column represents the category of the detected object, and the seventh column represents the confidence score of the detection.</p> Source code in <code>trackreid/reid_processor.py</code> <pre><code>@staticmethod\ndef print_input_data_format_requirements():\n\"\"\"\n\n    Prints the input data format requirements.\n\n    All input data should be of numeric type, either integers or floats.\n    Here's an example of how the input data should look like based on the schema:\n\n    |    bbox (0-3)   | object_id (4) | category (5) | confidence (6) |\n    |-----------------|---------------|--------------|----------------|\n    | 50, 60, 120, 80 |       1       |       1      |       0.91     |\n    | 50, 60, 120, 80 |       2       |       0      |       0.54     |\n\n    Each row represents a detected object. The first four columns represent the bounding box coordinates\n    (x, y, width, height), the fifth column represents the object ID assigned by the tracker,\n    the sixth column represents the category of the detected object, and the seventh column represents\n    the confidence score of the detection.\n    \"\"\"\n    input_schema = input_data_positions.model_json_schema()\n\n    print(\"Input Data Format Requirements:\")\n    for name, properties in input_schema[\"properties\"].items():\n        print(\"-\" * 50)\n        print(f\"{name}: {properties['description']}\")\n        print(\n            f\"{name} (position of {name} in the input array must be): {properties['default']}\"\n        )\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.print_output_data_format_information","title":"<code>print_output_data_format_information()</code>  <code>staticmethod</code>","text":"<p>Prints the output data format information.</p> <p>Here's an example of how the output data looks like based on the schema:</p> frame_id (0) object_id (1) category (2) bbox (3-6) confidence (7) mean_confidence (8) tracker_id (9) 1 1 1 50,60,120,80 0.91 0.85 1 2 2 0 50,60,120,80 0.54 0.60 2 Source code in <code>trackreid/reid_processor.py</code> <pre><code>@staticmethod\ndef print_output_data_format_information():\n\"\"\"\n    Prints the output data format information.\n\n    Here's an example of how the output data looks like based on the schema:\n\n    | frame_id (0) | object_id (1) | category (2) | bbox (3-6) | confidence (7) | mean_confidence (8) | tracker_id (9) |\n    |--------------|---------------|--------------|------------|----------------|-------------------|------------------|\n    | 1            | 1             | 1            | 50,60,120,80 | 0.91         | 0.85              | 1                |\n    | 2            | 2             | 0            | 50,60,120,80 | 0.54         | 0.60              | 2                |\n\n    \"\"\"  # noqa: E501\n    output_schema = output_data_positions.model_json_schema()\n\n    print(\"\\nOutput Data Format:\")\n    for name, properties in output_schema[\"properties\"].items():\n        print(\"-\" * 50)\n        print(f\"{name}: {properties['description']}\")\n        print(\n            f\"{name} (position of {name} in the output array will be): {properties['default']}\"\n        )\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.reset","title":"<code>reset(self)</code>","text":"<p>Resets the ReID processor state for a new processing sequence.</p> <p>This method resets the frame counter to zero and clears all tracked objects and the last frame's tracked objects from memory, preparing the processor for a new sequence of frames.</p> Source code in <code>trackreid/reid_processor.py</code> <pre><code>def reset(self) -&gt; None:\n\"\"\"\n    Resets the ReID processor state for a new processing sequence.\n\n    This method resets the frame counter to zero and clears all tracked objects\n    and the last frame's tracked objects from memory, preparing the processor\n    for a new sequence of frames.\n    \"\"\"\n    self.frame_id = 0\n    self.all_tracked_objects: List[TrackedObject] = []\n    self.last_frame_tracked_objects: Set[TrackedObject] = set()\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.set_file_path","title":"<code>set_file_path(self, new_file_path)</code>","text":"<p>Sets a new file path for saving txt data.</p> <p>Parameters:</p> Name Type Description Default <code>new_file_path</code> <code>str</code> <p>The new file path.</p> required Source code in <code>trackreid/reid_processor.py</code> <pre><code>def set_file_path(self, new_file_path: str) -&gt; None:\n\"\"\"\n    Sets a new file path for saving txt data.\n\n    Args:\n        new_file_path (str): The new file path.\n    \"\"\"\n    self.file_path = new_file_path\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Converts the tracked objects to a dictionary.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>The dictionary representation of the tracked objects.</p> Source code in <code>trackreid/reid_processor.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n\"\"\"\n    Converts the tracked objects to a dictionary.\n\n    Returns:\n        Dict: The dictionary representation of the tracked objects.\n    \"\"\"\n    data = dict()\n    for tracked_object in self.all_tracked_objects:\n        data[tracked_object.object_id] = tracked_object.to_dict()\n    return data\n</code></pre>"},{"location":"reference/reid_processor/#trackreid.reid_processor.ReidProcessor.update","title":"<code>update(self, tracker_output, frame_id)</code>","text":"<p>Processes the tracker output and updates internal states.</p> <p>All input data should be of numeric type, either integers or floats. Here's an example of how the input data should look like based on the schema:</p> bbox (0-3) object_id (4) category (5) confidence (6) 50, 60, 120, 80 1 1 0.91 50, 60, 120, 80 2 0 0.54 <p>Each row represents a detected object. The first four columns represent the bounding box coordinates (x, y, width, height), the fifth column represents the object ID assigned by the tracker, the sixth column represents the category of the detected object, and the seventh column represents the confidence score of the detection.</p> <p>You can use ReidProcessor.print_input_data_requirements() for more insight.</p> <p>Here's an example of how the output data looks like based on the schema:</p> frame_id (0) object_id (1) category (2) bbox (3-6) confidence (7) mean_confidence (8) tracker_id (9) 1 1 1 50, 60, 120, 80 0.91 0.85 1 2 2 0 50, 60, 120, 80 0.54 0.60 2 <p>You can use ReidProcessor.print_output_data_format_information() for more insight.</p> <p>Parameters:</p> Name Type Description Default <code>tracker_output</code> <code>np.ndarray</code> <p>The tracker output.</p> required <code>frame_id</code> <code>int</code> <p>The frame id.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>The processed output.</p> Source code in <code>trackreid/reid_processor.py</code> <pre><code>def update(self, tracker_output: np.ndarray, frame_id: int) -&gt; np.ndarray:\n\"\"\"\n    Processes the tracker output and updates internal states.\n\n    All input data should be of numeric type, either integers or floats.\n    Here's an example of how the input data should look like based on the schema:\n\n    | bbox (0-3)      | object_id (4) | category (5) | confidence (6) |\n    |-----------------|---------------|--------------|----------------|\n    | 50, 60, 120, 80 |       1       |       1      |       0.91     |\n    | 50, 60, 120, 80 |       2       |       0      |       0.54     |\n\n    Each row represents a detected object. The first four columns represent the bounding box coordinates\n    (x, y, width, height), the fifth column represents the object ID assigned by the tracker,\n    the sixth column represents the category of the detected object, and the seventh column represents\n    the confidence score of the detection.\n\n    You can use ReidProcessor.print_input_data_requirements() for more insight.\n\n    Here's an example of how the output data looks like based on the schema:\n\n    | frame_id (0) | object_id (1) | category (2) | bbox (3-6)      | confidence (7) | mean_confidence (8) | tracker_id (9) |\n    |--------------|---------------|--------------|-----------------|----------------|---------------------|----------------|\n    | 1            | 1             | 1            | 50, 60, 120, 80 | 0.91           | 0.85                | 1              |\n    | 2            | 2             | 0            | 50, 60, 120, 80 | 0.54           | 0.60                | 2              |\n\n    You can use ReidProcessor.print_output_data_format_information() for more insight.\n\n    Args:\n        tracker_output (np.ndarray): The tracker output.\n        frame_id (int): The frame id.\n\n    Returns:\n        np.ndarray: The processed output.\n    \"\"\"  # noqa: E501\n    if tracker_output.size:  # empty tracking\n        self.all_tracked_objects, current_tracker_ids = self._preprocess(\n            tracker_output=tracker_output, frame_id=frame_id\n        )\n        self._perform_reid_process(current_tracker_ids=current_tracker_ids)\n        reid_output = self._postprocess(current_tracker_ids=current_tracker_ids)\n\n    else:\n        reid_output = tracker_output\n\n    if self.save_to_txt:\n        self._save_results_to_txt(file_path=self.file_path, reid_output=reid_output)\n\n    return reid_output\n</code></pre>"},{"location":"reference/selection_functions/","title":"Selection Functions","text":"<p>In the codebase, a selection function is used to determine whether two objects, specifically TrackedObjects instances, should be considered for matching. The selection function is a key part of the matching process in the Matcher class.</p> <p>The selection function influences the behavior of the matching process in the following ways:</p> <ol> <li> <p>Filtering Candidates: The selection function is used to filter out pairs of objects that should not be considered for matching. This can help reduce the computational complexity of the matching process by reducing the size of the cost matrix.</p> </li> <li> <p>Customizing Matching Criteria: The selection function allows you to customize the criteria for considering a pair of objects for matching. For example, you might want to only consider pairs of objects that belong to the same category, or pairs of objects that belong to the same area / zone.</p> </li> <li> <p>Improving Match Quality: By carefully choosing or designing a selection function, you can improve the quality of the matches. For example, a selection function that only considers pairs of objects with similar appearance features might lead to more accurate matches.</p> </li> </ol> <p>The selection function should return a boolean value. A return value of <code>True</code> or <code>1</code> indicates that the pair of objects should be considered for matching, while a return value of <code>False</code> or <code>0</code> indicates that the pair should not be considered.</p> <p>You can provide a custom selection function to the reidentification process. For more information, please refer to this documentation.</p>"},{"location":"reference/selection_functions/#trackreid.selection_functions.select_by_category","title":"<code>select_by_category</code>","text":""},{"location":"reference/selection_functions/#trackreid.selection_functions.select_by_category.select_by_category","title":"<code>select_by_category(candidate, switcher)</code>","text":"<p>Compares the categories of two TrackedObject instances. This selection function is used as a measure of similarity between the two objects, matches are discard if this function returns 0.</p> <p>Parameters:</p> Name Type Description Default <code>candidate</code> <code>TrackedObject</code> <p>The first TrackedObject instance.</p> required <code>switcher</code> <code>TrackedObject</code> <p>The second TrackedObject instance.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Returns 1 if the categories of the two objects are the same, otherwise returns 0.</p> Source code in <code>trackreid/selection_functions/select_by_category.py</code> <pre><code>def select_by_category(candidate: TrackedObject, switcher: TrackedObject) -&gt; int:\n\"\"\"\n    Compares the categories of two TrackedObject instances.\n    This selection function is used as a measure of similarity between the two objects,\n    matches are discard if this function returns 0.\n\n    Args:\n        candidate (TrackedObject): The first TrackedObject instance.\n        switcher (TrackedObject): The second TrackedObject instance.\n\n    Returns:\n        int: Returns 1 if the categories of the two objects are the same, otherwise returns 0.\n    \"\"\"\n    # Compare the categories of the two objects\n    return 1 if candidate.category == switcher.category else 0\n</code></pre>"},{"location":"reference/tracked_object/","title":"TrackedObject","text":""},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject","title":"<code> TrackedObject        </code>","text":"<p>The TrackedObject class represents an object that is being tracked in a video frame. It contains information about the object's state, its unique identifiers, and metadata.</p> <p>The object's state is an integer that represents the current state of the object in the reid process. The states can take the following values:</p> <ul> <li>LOST_FOREVER (-3): \"Switcher never rematched\"</li> <li>TRACKER_OUTPUT (-2): \"Tracker output not in reid process\"</li> <li>FILTERED_OUTPUT (-1): \"Tracker output entering reid process\"</li> <li>STABLE (0): \"Stable object\"</li> <li>SWITCHER (1): \"Lost object to be re-matched\"</li> <li>CANDIDATE (2): \"New object to be matched\"</li> </ul> <p>The object's unique identifiers are stored in a singly linked list (sllist) called re_id_chain. The re_id_chain is a crucial component in the codebase. It stores the history of the object's unique identifiers, allowing for tracking of the object across different frames. The first value in the re_id_chain is the original object ID, while the last value is the most recent tracker ID assigned to the object.</p> <p>The metadata is an instance of the TrackedObjectMetaData class, which contains additional information about the object.</p> <p>The TrackedObject class provides several methods for manipulating and accessing the data it contains. These include methods for merging two TrackedObject instances, updating the metadata, and converting the TrackedObject instance to a dictionary or JSON string.</p> <p>The TrackedObject class also provides several properties for accessing specific pieces of data, such as the object's unique identifier, its state, and its metadata.</p> <p>Parameters:</p> Name Type Description Default <code>object_ids</code> <code>Union[Union[float, int], sllist]</code> <p>The unique identifiers for the object.</p> required <code>state</code> <code>int</code> <p>The current state of the object.</p> required <code>metadata</code> <code>Union[np.ndarray, TrackedObjectMetaData]</code> <p>The metadata for the object. It can be either a TrackedObjectMetaData object, or a data line, i.e. output of detection model. If metadata is initialized with a TrackedObjectMetaData object, a frame_id must be given.</p> required <code>frame_id</code> <code>Optional[int]</code> <p>The frame ID where the object was first seen. Defaults to None.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>NameError</code> <p>If the type of object_ids or metadata is unrecognized.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>class TrackedObject:\n\"\"\"\n    The TrackedObject class represents an object that is being tracked in a video frame.\n    It contains information about the object's state, its unique identifiers, and metadata.\n\n    The object's state is an integer that represents the current state of the object in the\n    reid process. The states can take the following values:\n\n    - LOST_FOREVER (-3): \"Switcher never rematched\"\n    - TRACKER_OUTPUT (-2): \"Tracker output not in reid process\"\n    - FILTERED_OUTPUT (-1): \"Tracker output entering reid process\"\n    - STABLE (0): \"Stable object\"\n    - SWITCHER (1): \"Lost object to be re-matched\"\n    - CANDIDATE (2): \"New object to be matched\"\n\n    The object's unique identifiers are stored in a singly linked list (sllist) called re_id_chain. The re_id_chain\n    is a crucial component in the codebase. It stores the history of the object's unique identifiers, allowing for\n    tracking of the object across different frames. The first value in the re_id_chain\n    is the original object ID, while the last value is the most recent tracker ID assigned to the object.\n\n    The metadata is an instance of the TrackedObjectMetaData class, which contains additional information\n    about the object.\n\n    The TrackedObject class provides several methods for manipulating and accessing the data it contains.\n    These include methods for merging two TrackedObject instances, updating the metadata, and converting the\n    TrackedObject instance to a dictionary or JSON string.\n\n    The TrackedObject class also provides several properties for accessing specific pieces of data, such as the object's\n    unique identifier, its state, and its metadata.\n\n    Args:\n        object_ids (Union[Union[float, int], sllist]): The unique identifiers for the object.\n        state (int): The current state of the object.\n        metadata (Union[np.ndarray, TrackedObjectMetaData]): The metadata for the object. It can be either a TrackedObjectMetaData object, or a data line, i.e. output of detection model. If metadata is initialized with a TrackedObjectMetaData object, a frame_id must be given.\n        frame_id (Optional[int], optional): The frame ID where the object was first seen. Defaults to None.\n\n    Raises:\n        NameError: If the type of object_ids or metadata is unrecognized.\n    \"\"\"  # noqa: E501\n\n    def __init__(\n        self,\n        object_ids: Union[Union[float, int], sllist],\n        state: int,\n        metadata: Union[np.ndarray, TrackedObjectMetaData],\n        frame_id: Optional[int] = None,\n    ):\n        self.state = state\n\n        if isinstance(object_ids, (float, int)):\n            self.re_id_chain = sllist([object_ids])\n        elif isinstance(object_ids, sllist):\n            self.re_id_chain = sllist(object_ids)\n        else:\n            raise NameError(\"unrocognized type for object_ids.\")\n        if isinstance(metadata, np.ndarray):\n            assert (\n                frame_id is not None\n            ), \"Please provide a frame_id for TrackedObject initialization\"\n            self.metadata = TrackedObjectMetaData(metadata, frame_id)\n        elif isinstance(metadata, TrackedObjectMetaData):\n            self.metadata = metadata.copy()\n        else:\n            raise NameError(\"unrocognized type for metadata.\")\n\n    def copy(self):\n        return TrackedObject(object_ids=self.re_id_chain, state=self.state, metadata=self.metadata)\n\n    def merge(self, other_object: TrackedObject):\n        if not isinstance(other_object, TrackedObject):\n            raise TypeError(\"Can only merge with another TrackedObject.\")\n\n        # Merge the re_id_chains\n        self.re_id_chain.extend(other_object.re_id_chain)\n        self.metadata.merge(other_object.metadata)\n        self.state = other_object.state\n\n        # Return the merged object\n        return self\n\n    @property\n    def object_id(self):\n\"\"\"\n        Returns the first value in the re_id_chain which represents the object id.\n        \"\"\"\n        return self.re_id_chain.first.value\n\n    @property\n    def tracker_id(self):\n\"\"\"\n        Returns the last value in the re_id_chain which represents the last tracker id.\n        \"\"\"\n        return self.re_id_chain.last.value\n\n    @property\n    def category(self):\n\"\"\"\n        Returns the category with the maximum count in the class_counts dictionary of the metadata.\n        \"\"\"\n        return max(self.metadata.class_counts, key=self.metadata.class_counts.get)\n\n    @property\n    def confidence(self):\n\"\"\"\n        Returns the confidence value from the metadata.\n        \"\"\"\n        return self.metadata.confidence\n\n    @property\n    def mean_confidence(self):\n\"\"\"\n        Returns the mean confidence value from the metadata.\n        \"\"\"\n        return self.metadata.mean_confidence()\n\n    @property\n    def class_proportions(self):\n\"\"\"\n        Returns the proportion of observations in each classes.\n        \"\"\"\n        return self.metadata.class_proportions()\n\n    @property\n    def bbox(self):\n\"\"\"\n        Returns the bounding box coordinates from the metadata.\n        \"\"\"\n        return self.metadata.bbox\n\n    @property\n    def nb_ids(self):\n\"\"\"\n        Returns the number of ids in the re_id_chain.\n        \"\"\"\n        return len(self.re_id_chain)\n\n    @property\n    def nb_corrections(self):\n\"\"\"\n        Returns the number of corrections which is the number of ids in the re_id_chain minus one.\n        \"\"\"\n        return self.nb_ids - 1\n\n    def get_percentage_of_time_seen(self, frame_id: int):\n\"\"\"\n        Calculates and returns the percentage of time the tracked object has been seen up to the given frame id.\n\n        Args:\n            frame_id (int): The current frame id.\n\n        Returns:\n            float: The percentage of time the tracked object has been seen.\n        \"\"\"\n        return self.metadata.percentage_of_time_seen(frame_id=frame_id)\n\n    def get_age(self, frame_id: int):\n\"\"\"\n        Calculates and returns the age of the tracked object based on the given frame id.\n        Age is defined as the difference between the current frame id and the first frame id where\n        the object was detected.\n\n        Args:\n            frame_id (int): The current frame id.\n\n        Returns:\n            int: The age of the tracked object based on the given frame id.\n        \"\"\"\n        return frame_id - self.metadata.first_frame_id\n\n    def get_nb_frames_since_last_appearance(self, frame_id: int):\n\"\"\"\n        Calculates and returns the number of frames since the last appearance of the tracked object.\n        This is computed as the difference between the current frame id and the last frame id where\n        the object was detected.\n\n        Args:\n            frame_id (int): The current frame id.\n\n        Returns:\n            int: The number of frames since the last appearance of the tracked object.\n        \"\"\"\n        return frame_id - self.metadata.last_frame_id\n\n    def get_state(self):\n\"\"\"\n        Returns the current state of the tracked object.\n        \"\"\"\n        return self.state\n\n    def __hash__(self):\n        return hash(self.object_id)\n\n    def __repr__(self):\n        return (\n            f\"TrackedObject(current_id={self.object_id}, re_id_chain={list(self.re_id_chain)}\"\n            + f\", state={self.state}: {reid_constants.STATES.DESCRIPTION[self.state]})\"\n        )\n\n    def __str__(self):\n        return f\"{self.__repr__()}, metadata : {self.metadata}\"\n\n    def update_metadata(self, data_line: np.ndarray, frame_id: int):\n\"\"\"\n        Updates the metadata of the tracked object based on new detection data.\n\n        This method is used to update the metadata of a tracked object whenever new detection data is available.\n        It updates the metadata by calling the update method of the TrackedObjectMetaData instance associated with\n        the tracked object.\n\n        Args:\n            data_line (np.ndarray): The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.\n\n            frame_id (int): The frame id where the object was detected. This is used to update the last frame id of the tracked object.\n        \"\"\"  # noqa: E501\n        self.metadata.update(data_line=data_line, frame_id=frame_id)\n\n    def __eq__(self, other):\n        if isinstance(other, (float, int)):\n            return other in self.re_id_chain\n        elif isinstance(other, TrackedObject):\n            return self.re_id_chain == other.re_id_chain\n        return False\n\n    def cut(self, object_id: int):\n\"\"\"\n        Splits the re_id_chain of the tracked object at the specified object_id and creates a new TrackedObject\n        instance with the remaining part of the re_id_chain. The original TrackedObject instance retains the part\n        of the re_id_chain before the specified object_id.\n\n        Args:\n            object_id (int): The object_id at which to split the re_id_chain.\n\n        Raises:\n            NameError: If the specified object_id is not found in the re_id_chain of the tracked object.\n\n        Returns:\n            tuple: A tuple containing the new TrackedObject instance and the original TrackedObject instance.\n        \"\"\"\n        if object_id not in self.re_id_chain:\n            raise NameError(\n                f\"Trying to cut object {self} with {object_id} that is not in the re-id chain.\"\n            )\n\n        before, after = split_list_around_value(self.re_id_chain, object_id)\n        self.re_id_chain = before\n\n        new_object = TrackedObject(\n            state=reid_constants.STATES.STABLE, object_ids=after, metadata=self.metadata\n        )\n        # set potential age 0 for new object\n        new_object.metadata.first_frame_id = new_object.metadata.last_frame_id\n        return new_object, self\n\n    def to_dict(self):\n\"\"\"\n        Converts the TrackedObject instance to a dictionary.\n\n        Returns:\n            dict: A dictionary representation of the TrackedObject instance.\n        \"\"\"\n        data = {\n            \"object_id\": float(self.object_id),\n            \"state\": int(self.state),\n            \"re_id_chain\": list(self.re_id_chain),\n            \"metadata\": self.metadata.to_dict(),\n        }\n        return data\n\n    @classmethod\n    def from_dict(cls, data: dict):\n\"\"\"\n        Creates a new TrackedObject instance from a dictionary.\n\n        Args:\n            data (dict): A dictionary containing the data for the TrackedObject instance.\n\n        Returns:\n            TrackedObject: A new TrackedObject instance created from the dictionary.\n        \"\"\"\n        obj = cls.__new__(cls)\n        obj.state = data[\"state\"]\n        obj.re_id_chain = sllist(data[\"re_id_chain\"])\n        obj.metadata = TrackedObjectMetaData.from_dict(data[\"metadata\"])\n        return obj\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.bbox","title":"<code>bbox</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the bounding box coordinates from the metadata.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.category","title":"<code>category</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the category with the maximum count in the class_counts dictionary of the metadata.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.class_proportions","title":"<code>class_proportions</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the proportion of observations in each classes.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.confidence","title":"<code>confidence</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the confidence value from the metadata.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.mean_confidence","title":"<code>mean_confidence</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the mean confidence value from the metadata.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.nb_corrections","title":"<code>nb_corrections</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the number of corrections which is the number of ids in the re_id_chain minus one.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.nb_ids","title":"<code>nb_ids</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the number of ids in the re_id_chain.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.object_id","title":"<code>object_id</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the first value in the re_id_chain which represents the object id.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.tracker_id","title":"<code>tracker_id</code>  <code>property</code> <code>readonly</code>","text":"<p>Returns the last value in the re_id_chain which represents the last tracker id.</p>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.cut","title":"<code>cut(self, object_id)</code>","text":"<p>Splits the re_id_chain of the tracked object at the specified object_id and creates a new TrackedObject instance with the remaining part of the re_id_chain. The original TrackedObject instance retains the part of the re_id_chain before the specified object_id.</p> <p>Parameters:</p> Name Type Description Default <code>object_id</code> <code>int</code> <p>The object_id at which to split the re_id_chain.</p> required <p>Exceptions:</p> Type Description <code>NameError</code> <p>If the specified object_id is not found in the re_id_chain of the tracked object.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing the new TrackedObject instance and the original TrackedObject instance.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def cut(self, object_id: int):\n\"\"\"\n    Splits the re_id_chain of the tracked object at the specified object_id and creates a new TrackedObject\n    instance with the remaining part of the re_id_chain. The original TrackedObject instance retains the part\n    of the re_id_chain before the specified object_id.\n\n    Args:\n        object_id (int): The object_id at which to split the re_id_chain.\n\n    Raises:\n        NameError: If the specified object_id is not found in the re_id_chain of the tracked object.\n\n    Returns:\n        tuple: A tuple containing the new TrackedObject instance and the original TrackedObject instance.\n    \"\"\"\n    if object_id not in self.re_id_chain:\n        raise NameError(\n            f\"Trying to cut object {self} with {object_id} that is not in the re-id chain.\"\n        )\n\n    before, after = split_list_around_value(self.re_id_chain, object_id)\n    self.re_id_chain = before\n\n    new_object = TrackedObject(\n        state=reid_constants.STATES.STABLE, object_ids=after, metadata=self.metadata\n    )\n    # set potential age 0 for new object\n    new_object.metadata.first_frame_id = new_object.metadata.last_frame_id\n    return new_object, self\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates a new TrackedObject instance from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the data for the TrackedObject instance.</p> required <p>Returns:</p> Type Description <code>TrackedObject</code> <p>A new TrackedObject instance created from the dictionary.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n\"\"\"\n    Creates a new TrackedObject instance from a dictionary.\n\n    Args:\n        data (dict): A dictionary containing the data for the TrackedObject instance.\n\n    Returns:\n        TrackedObject: A new TrackedObject instance created from the dictionary.\n    \"\"\"\n    obj = cls.__new__(cls)\n    obj.state = data[\"state\"]\n    obj.re_id_chain = sllist(data[\"re_id_chain\"])\n    obj.metadata = TrackedObjectMetaData.from_dict(data[\"metadata\"])\n    return obj\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.get_age","title":"<code>get_age(self, frame_id)</code>","text":"<p>Calculates and returns the age of the tracked object based on the given frame id. Age is defined as the difference between the current frame id and the first frame id where the object was detected.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The current frame id.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The age of the tracked object based on the given frame id.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def get_age(self, frame_id: int):\n\"\"\"\n    Calculates and returns the age of the tracked object based on the given frame id.\n    Age is defined as the difference between the current frame id and the first frame id where\n    the object was detected.\n\n    Args:\n        frame_id (int): The current frame id.\n\n    Returns:\n        int: The age of the tracked object based on the given frame id.\n    \"\"\"\n    return frame_id - self.metadata.first_frame_id\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.get_nb_frames_since_last_appearance","title":"<code>get_nb_frames_since_last_appearance(self, frame_id)</code>","text":"<p>Calculates and returns the number of frames since the last appearance of the tracked object. This is computed as the difference between the current frame id and the last frame id where the object was detected.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The current frame id.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of frames since the last appearance of the tracked object.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def get_nb_frames_since_last_appearance(self, frame_id: int):\n\"\"\"\n    Calculates and returns the number of frames since the last appearance of the tracked object.\n    This is computed as the difference between the current frame id and the last frame id where\n    the object was detected.\n\n    Args:\n        frame_id (int): The current frame id.\n\n    Returns:\n        int: The number of frames since the last appearance of the tracked object.\n    \"\"\"\n    return frame_id - self.metadata.last_frame_id\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.get_percentage_of_time_seen","title":"<code>get_percentage_of_time_seen(self, frame_id)</code>","text":"<p>Calculates and returns the percentage of time the tracked object has been seen up to the given frame id.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The current frame id.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The percentage of time the tracked object has been seen.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def get_percentage_of_time_seen(self, frame_id: int):\n\"\"\"\n    Calculates and returns the percentage of time the tracked object has been seen up to the given frame id.\n\n    Args:\n        frame_id (int): The current frame id.\n\n    Returns:\n        float: The percentage of time the tracked object has been seen.\n    \"\"\"\n    return self.metadata.percentage_of_time_seen(frame_id=frame_id)\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.get_state","title":"<code>get_state(self)</code>","text":"<p>Returns the current state of the tracked object.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def get_state(self):\n\"\"\"\n    Returns the current state of the tracked object.\n    \"\"\"\n    return self.state\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Converts the TrackedObject instance to a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the TrackedObject instance.</p> Source code in <code>trackreid/tracked_object.py</code> <pre><code>def to_dict(self):\n\"\"\"\n    Converts the TrackedObject instance to a dictionary.\n\n    Returns:\n        dict: A dictionary representation of the TrackedObject instance.\n    \"\"\"\n    data = {\n        \"object_id\": float(self.object_id),\n        \"state\": int(self.state),\n        \"re_id_chain\": list(self.re_id_chain),\n        \"metadata\": self.metadata.to_dict(),\n    }\n    return data\n</code></pre>"},{"location":"reference/tracked_object/#trackreid.tracked_object.TrackedObject.update_metadata","title":"<code>update_metadata(self, data_line, frame_id)</code>","text":"<p>Updates the metadata of the tracked object based on new detection data.</p> <p>This method is used to update the metadata of a tracked object whenever new detection data is available. It updates the metadata by calling the update method of the TrackedObjectMetaData instance associated with the tracked object.</p> <p>Parameters:</p> Name Type Description Default <code>data_line</code> <code>np.ndarray</code> <p>The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.</p> required <code>frame_id</code> <code>int</code> <p>The frame id where the object was detected. This is used to update the last frame id of the tracked object.</p> required Source code in <code>trackreid/tracked_object.py</code> <pre><code>def update_metadata(self, data_line: np.ndarray, frame_id: int):\n\"\"\"\n    Updates the metadata of the tracked object based on new detection data.\n\n    This method is used to update the metadata of a tracked object whenever new detection data is available.\n    It updates the metadata by calling the update method of the TrackedObjectMetaData instance associated with\n    the tracked object.\n\n    Args:\n        data_line (np.ndarray): The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.\n\n        frame_id (int): The frame id where the object was detected. This is used to update the last frame id of the tracked object.\n    \"\"\"  # noqa: E501\n    self.metadata.update(data_line=data_line, frame_id=frame_id)\n</code></pre>"},{"location":"reference/tracked_object_filter/","title":"TrackedObjectFilter","text":""},{"location":"reference/tracked_object_filter/#trackreid.tracked_object_filter.TrackedObjectFilter","title":"<code> TrackedObjectFilter        </code>","text":"<p>The TrackedObjectFilter class is used to filter tracked objects based on their confidence and the number of frames they have been observed in.</p> <p>Parameters:</p> Name Type Description Default <code>confidence_threshold</code> <code>float</code> <p>The minimum mean confidence level required for a tracked object to be considered valid.</p> required <code>frames_seen_threshold</code> <code>int</code> <p>The minimum number of frames a tracked object must be observed in to be considered valid.</p> required Source code in <code>trackreid/tracked_object_filter.py</code> <pre><code>class TrackedObjectFilter:\n\"\"\"\n    The TrackedObjectFilter class is used to filter tracked objects based on their\n    confidence and the number of frames they have been observed in.\n\n    Args:\n        confidence_threshold (float): The minimum mean confidence level required for a tracked object to be considered valid.\n        frames_seen_threshold (int): The minimum number of frames a tracked object must be observed in to be considered valid.\n    \"\"\"  # noqa: E501\n\n    def __init__(self, confidence_threshold: float, frames_seen_threshold: int):\n        self.confidence_threshold = confidence_threshold\n        self.frames_seen_threshold = frames_seen_threshold\n\n    def update(self, tracked_object: TrackedObject):\n\"\"\"\n        The update method is used to update the state of a tracked object based on its confidence\n        and the number of frames it has been observed in.\n\n        If the tracked object's state is TRACKER_OUTPUT, and its mean confidence is greater than the\n        confidence_threshold, and it has been observed in more frames than the frames_seen_threshold,\n        its state is updated to FILTERED_OUTPUT.\n\n        If the tracked object's mean confidence is less than the confidence_threshold, its state is\n        updated to TRACKER_OUTPUT.\n\n        Args:\n            tracked_object (TrackedObject): The tracked object to update.\n        \"\"\"\n        if tracked_object.get_state() == reid_constants.STATES.TRACKER_OUTPUT:\n            if (\n                tracked_object.metadata.mean_confidence() &gt; self.confidence_threshold\n                and tracked_object.metadata.observations &gt;= self.frames_seen_threshold\n            ):\n                tracked_object.state = reid_constants.STATES.FILTERED_OUTPUT\n\n        elif tracked_object.metadata.mean_confidence() &lt; self.confidence_threshold:\n            tracked_object.state = reid_constants.STATES.TRACKER_OUTPUT\n</code></pre>"},{"location":"reference/tracked_object_filter/#trackreid.tracked_object_filter.TrackedObjectFilter.update","title":"<code>update(self, tracked_object)</code>","text":"<p>The update method is used to update the state of a tracked object based on its confidence and the number of frames it has been observed in.</p> <p>If the tracked object's state is TRACKER_OUTPUT, and its mean confidence is greater than the confidence_threshold, and it has been observed in more frames than the frames_seen_threshold, its state is updated to FILTERED_OUTPUT.</p> <p>If the tracked object's mean confidence is less than the confidence_threshold, its state is updated to TRACKER_OUTPUT.</p> <p>Parameters:</p> Name Type Description Default <code>tracked_object</code> <code>TrackedObject</code> <p>The tracked object to update.</p> required Source code in <code>trackreid/tracked_object_filter.py</code> <pre><code>def update(self, tracked_object: TrackedObject):\n\"\"\"\n    The update method is used to update the state of a tracked object based on its confidence\n    and the number of frames it has been observed in.\n\n    If the tracked object's state is TRACKER_OUTPUT, and its mean confidence is greater than the\n    confidence_threshold, and it has been observed in more frames than the frames_seen_threshold,\n    its state is updated to FILTERED_OUTPUT.\n\n    If the tracked object's mean confidence is less than the confidence_threshold, its state is\n    updated to TRACKER_OUTPUT.\n\n    Args:\n        tracked_object (TrackedObject): The tracked object to update.\n    \"\"\"\n    if tracked_object.get_state() == reid_constants.STATES.TRACKER_OUTPUT:\n        if (\n            tracked_object.metadata.mean_confidence() &gt; self.confidence_threshold\n            and tracked_object.metadata.observations &gt;= self.frames_seen_threshold\n        ):\n            tracked_object.state = reid_constants.STATES.FILTERED_OUTPUT\n\n    elif tracked_object.metadata.mean_confidence() &lt; self.confidence_threshold:\n        tracked_object.state = reid_constants.STATES.TRACKER_OUTPUT\n</code></pre>"},{"location":"reference/tracked_object_metadata/","title":"TrackedObjectMetadata","text":""},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData","title":"<code> TrackedObjectMetaData        </code>","text":"<p>The TrackedObjectMetaData class is used to store and manage metadata for tracked objects in a video frame. This metadata includes information such as the frame ID where the object was first seen, the class counts (how many times each class was detected), the bounding box coordinates, and the confidence level of the detection.</p> <p>This metadata is then use in selection and cost functions to compute likelihood of a match between two objects.</p> <p>Usage: An instance of TrackedObjectMetaData is created by passing a data_line (which contains the detection data for a single frame) and a frame_id (which identifies the frame where the object was detected).</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>class TrackedObjectMetaData:\n\"\"\"\n    The TrackedObjectMetaData class is used to store and manage metadata for tracked objects in a video frame.\n    This metadata includes information such as the frame ID where the object was first seen, the class counts\n    (how many times each class was detected), the bounding box coordinates, and the confidence level of the detection.\n\n    This metadata is then use in selection and cost functions to compute likelihood of a match between two objects.\n\n    Usage:\n    An instance of TrackedObjectMetaData is created by passing a data_line (which contains the detection data\n    for a single frame) and a frame_id (which identifies the frame where the object was detected).\n    \"\"\"\n\n    def __init__(self, data_line: np.ndarray, frame_id: int):\n        self.first_frame_id = frame_id\n        self.class_counts = {}\n        self.observations = 0\n        self.confidence_sum = 0\n        self.confidence = 0\n        self.update(data_line, frame_id)\n\n    def update(self, data_line: np.ndarray, frame_id: int):\n\"\"\"\n        Updates the metadata of a tracked object based on new detection data.\n\n        This method is used to update the metadata of a tracked object whenever new detection data is available.\n        It updates the last frame id, class counts, bounding box, confidence, confidence sum, and observations:\n            - last_frame_id: Updated to the frame id where the object was detected\n            - class_counts: Incremented by 1 for the detected class\n            - bbox: Updated to the bounding box coordinates from the detection data\n            - confidence: Updated to the confidence level from the detection data\n            - confidence_sum: Incremented by the confidence level from the detection data\n            - observations: Incremented by 1\n\n        Args:\n            data_line (np.ndarra): The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.\n\n            frame_id (int): The frame id where the object was detected. This is used to update the last frame id of the tracked object.\n\n        \"\"\"  # noqa: E501\n        self.last_frame_id = frame_id\n\n        class_name = int(data_line[input_data_positions.category])\n        self.class_counts[class_name] = self.class_counts.get(class_name, 0) + 1\n        self.bbox = list(data_line[input_data_positions.bbox])\n        confidence = float(data_line[input_data_positions.confidence])\n        self.confidence = confidence\n        self.confidence_sum += confidence\n        self.observations += 1\n\n    def merge(self, other_object):\n\"\"\"\n        Merges the metadata of another TrackedObjectMetaData instance into the current one.\n        Updates the current instance with the data from the other TrackedObjectMetaData instance.\n\n        The following properties are updated:\n            - observations: Incremented by the observations of the other object.\n            - confidence_sum: Incremented by the confidence sum of the other object.\n            - confidence: Set to the confidence of the other object.\n            - bbox: Set to the bounding box of the other object.\n            - last_frame_id: Set to the last frame id of the other object.\n            - class_counts: For each class, the count is incremented by the count of the other object.\n\n        Args:\n            other_object (TrackedObjectMetaData): The other TrackedObjectMetaData instance whose metadata is to be merged with the current instance.\n\n        Raises:\n            TypeError: If the other_object is not an instance of TrackedObjectMetaData.\n\n        \"\"\"  # noqa: E501\n        if not isinstance(other_object, type(self)):\n            raise TypeError(\"Can only merge with another TrackedObjectMetaData.\")\n\n        self.observations += other_object.observations\n        self.confidence_sum += other_object.confidence_sum\n        self.confidence = other_object.confidence\n        self.bbox = other_object.bbox\n        self.last_frame_id = other_object.last_frame_id\n        for class_name in other_object.class_counts.keys():\n            self.class_counts[class_name] = self.class_counts.get(\n                class_name, 0\n            ) + other_object.class_counts.get(class_name, 0)\n\n    def copy(self):\n\"\"\"\n        Creates a copy of the current TrackedObjectMetaData instance.\n\n        Returns:\n            TrackedObjectMetaData: A new instance of TrackedObjectMetaData with the same\n            properties as the current instance.\n        \"\"\"\n        copy_obj = TrackedObjectMetaData.__new__(TrackedObjectMetaData)\n        copy_obj.bbox = self.bbox.copy()\n        copy_obj.class_counts = self.class_counts.copy()\n        copy_obj.observations = self.observations\n        copy_obj.confidence_sum = self.confidence_sum\n        copy_obj.confidence = self.confidence\n        copy_obj.first_frame_id = self.first_frame_id\n        copy_obj.last_frame_id = self.last_frame_id\n\n        return copy_obj\n\n    def to_dict(self):\n\"\"\"\n        Converts the TrackedObjectMetaData instance to a dictionary.\n\n        The class_counts dictionary is converted to a string-keyed dictionary.\n        The bounding box list is converted to a list of integers.\n        The first_frame_id, last_frame_id, confidence, confidence_sum, and observations are converted to their\n        respective types.\n\n        Returns:\n            dict: A dictionary representation of the TrackedObjectMetaData instance.\n        \"\"\"\n        class_counts_str = {\n            str(class_name): count for class_name, count in self.class_counts.items()\n        }\n        data = {\n            \"first_frame_id\": int(self.first_frame_id),\n            \"last_frame_id\": int(self.last_frame_id),\n            \"class_counts\": class_counts_str,\n            \"bbox\": self.bbox,\n            \"confidence\": float(self.confidence),\n            \"confidence_sum\": float(self.confidence_sum),\n            \"observations\": int(self.observations),\n        }\n        return data\n\n    def to_json(self):\n\"\"\"\n        Converts the TrackedObjectMetaData instance to a JSON string.\n\n        Returns:\n            str: A JSON string representation of the TrackedObjectMetaData instance.\n        \"\"\"\n        return json.dumps(self.to_dict(), indent=4)\n\n    @classmethod\n    def from_dict(cls, data: dict):\n\"\"\"\n        Creates a new instance of the class from a dictionary.\n\n        The dictionary should contain the following keys: \"first_frame_id\", \"last_frame_id\", \"class_counts\",\n        \"bbox\", \"confidence\", \"confidence_sum\", and \"observations\". The \"class_counts\" key should map to a\n        dictionary where the keys are class names (as integers) and the values are counts.\n\n        Args:\n            data (dict): A dictionary containing the data to populate the new instance.\n\n        Returns:\n            TrackedObjectMetaData: A new instance of TrackedObjectMetaData populated with the data from the dictionary.\n        \"\"\"\n        class_counts_str = data[\"class_counts\"]\n        class_counts = {int(class_name): count for class_name, count in class_counts_str.items()}\n        obj = cls.__new__(cls)\n        obj.first_frame_id = data[\"first_frame_id\"]\n        obj.last_frame_id = data[\"last_frame_id\"]\n        obj.class_counts = class_counts\n        obj.bbox = data[\"bbox\"]\n        obj.confidence = data[\"confidence\"]\n        obj.confidence_sum = data[\"confidence_sum\"]\n        obj.observations = data[\"observations\"]\n        return obj\n\n    @classmethod\n    def from_json(cls, json_str: str):\n\"\"\"\n        Creates a new instance of the class from a JSON string.\n\n        Args:\n            json_str (str): A JSON string representation of the TrackedObjectMetaData instance.\n\n        Returns:\n            TrackedObjectMetaData: A new instance of TrackedObjectMetaData populated with the data from the JSON string.\n        \"\"\"\n        data = json.loads(json_str)\n        return cls.from_dict(data)\n\n    def class_proportions(self):\n\"\"\"\n        Calculates the proportions of each class in the tracked object.\n\n        Returns:\n            dict: A dictionary where the keys are class names and the values are the proportions of each class.\n        \"\"\"\n        if self.observations &gt; 0:\n            proportions = {\n                class_name: count / self.observations\n                for class_name, count in self.class_counts.items()\n            }\n        else:\n            proportions = {}\n        return proportions\n\n    def percentage_of_time_seen(self, frame_id: int):\n\"\"\"\n        Calculates the percentage of time the tracked object has been seen.\n\n        Args:\n            frame_id (int): The current frame id.\n\n        Returns:\n            float: The percentage of time the tracked object has been seen.\n        \"\"\"\n        if self.observations &gt; 0:\n            percentage = (self.observations / (frame_id - self.first_frame_id + 1)) * 100\n        else:\n            percentage = 0.0\n        return percentage\n\n    def mean_confidence(self):\n\"\"\"\n        Calculates the mean confidence of the tracked object.\n\n        Returns:\n            float: The mean confidence of the tracked object.\n        \"\"\"\n        if self.observations &gt; 0:\n            return self.confidence_sum / self.observations\n        else:\n            return 0.0\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Returns a string representation of the TrackedObjectMetaData instance.\n\n        Returns:\n            str: A string representation of the TrackedObjectMetaData instance.\n        \"\"\"\n        return f\"TrackedObjectMetaData(bbox={self.bbox})\"\n\n    def __str__(self):\n\"\"\"\n        Returns a string representation of the TrackedObjectMetaData instance.\n\n        Returns:\n            str: A string representation of the TrackedObjectMetaData instance.\n        \"\"\"\n        return (\n            f\"First frame seen: {self.first_frame_id}, nb observations: {self.observations}, \"\n            + f\"class proportions: {self.class_proportions()}, bbox: {self.bbox}, \"\n            + f\"mean confidence: {self.mean_confidence()}\"\n        )\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Returns a string representation of the TrackedObjectMetaData instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the TrackedObjectMetaData instance.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Returns a string representation of the TrackedObjectMetaData instance.\n\n    Returns:\n        str: A string representation of the TrackedObjectMetaData instance.\n    \"\"\"\n    return f\"TrackedObjectMetaData(bbox={self.bbox})\"\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.__str__","title":"<code>__str__(self)</code>  <code>special</code>","text":"<p>Returns a string representation of the TrackedObjectMetaData instance.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the TrackedObjectMetaData instance.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def __str__(self):\n\"\"\"\n    Returns a string representation of the TrackedObjectMetaData instance.\n\n    Returns:\n        str: A string representation of the TrackedObjectMetaData instance.\n    \"\"\"\n    return (\n        f\"First frame seen: {self.first_frame_id}, nb observations: {self.observations}, \"\n        + f\"class proportions: {self.class_proportions()}, bbox: {self.bbox}, \"\n        + f\"mean confidence: {self.mean_confidence()}\"\n    )\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.class_proportions","title":"<code>class_proportions(self)</code>","text":"<p>Calculates the proportions of each class in the tracked object.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary where the keys are class names and the values are the proportions of each class.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def class_proportions(self):\n\"\"\"\n    Calculates the proportions of each class in the tracked object.\n\n    Returns:\n        dict: A dictionary where the keys are class names and the values are the proportions of each class.\n    \"\"\"\n    if self.observations &gt; 0:\n        proportions = {\n            class_name: count / self.observations\n            for class_name, count in self.class_counts.items()\n        }\n    else:\n        proportions = {}\n    return proportions\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.copy","title":"<code>copy(self)</code>","text":"<p>Creates a copy of the current TrackedObjectMetaData instance.</p> <p>Returns:</p> Type Description <code>TrackedObjectMetaData</code> <p>A new instance of TrackedObjectMetaData with the same properties as the current instance.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def copy(self):\n\"\"\"\n    Creates a copy of the current TrackedObjectMetaData instance.\n\n    Returns:\n        TrackedObjectMetaData: A new instance of TrackedObjectMetaData with the same\n        properties as the current instance.\n    \"\"\"\n    copy_obj = TrackedObjectMetaData.__new__(TrackedObjectMetaData)\n    copy_obj.bbox = self.bbox.copy()\n    copy_obj.class_counts = self.class_counts.copy()\n    copy_obj.observations = self.observations\n    copy_obj.confidence_sum = self.confidence_sum\n    copy_obj.confidence = self.confidence\n    copy_obj.first_frame_id = self.first_frame_id\n    copy_obj.last_frame_id = self.last_frame_id\n\n    return copy_obj\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates a new instance of the class from a dictionary.</p> <p>The dictionary should contain the following keys: \"first_frame_id\", \"last_frame_id\", \"class_counts\", \"bbox\", \"confidence\", \"confidence_sum\", and \"observations\". The \"class_counts\" key should map to a dictionary where the keys are class names (as integers) and the values are counts.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the data to populate the new instance.</p> required <p>Returns:</p> Type Description <code>TrackedObjectMetaData</code> <p>A new instance of TrackedObjectMetaData populated with the data from the dictionary.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n\"\"\"\n    Creates a new instance of the class from a dictionary.\n\n    The dictionary should contain the following keys: \"first_frame_id\", \"last_frame_id\", \"class_counts\",\n    \"bbox\", \"confidence\", \"confidence_sum\", and \"observations\". The \"class_counts\" key should map to a\n    dictionary where the keys are class names (as integers) and the values are counts.\n\n    Args:\n        data (dict): A dictionary containing the data to populate the new instance.\n\n    Returns:\n        TrackedObjectMetaData: A new instance of TrackedObjectMetaData populated with the data from the dictionary.\n    \"\"\"\n    class_counts_str = data[\"class_counts\"]\n    class_counts = {int(class_name): count for class_name, count in class_counts_str.items()}\n    obj = cls.__new__(cls)\n    obj.first_frame_id = data[\"first_frame_id\"]\n    obj.last_frame_id = data[\"last_frame_id\"]\n    obj.class_counts = class_counts\n    obj.bbox = data[\"bbox\"]\n    obj.confidence = data[\"confidence\"]\n    obj.confidence_sum = data[\"confidence_sum\"]\n    obj.observations = data[\"observations\"]\n    return obj\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Creates a new instance of the class from a JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>A JSON string representation of the TrackedObjectMetaData instance.</p> required <p>Returns:</p> Type Description <code>TrackedObjectMetaData</code> <p>A new instance of TrackedObjectMetaData populated with the data from the JSON string.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str):\n\"\"\"\n    Creates a new instance of the class from a JSON string.\n\n    Args:\n        json_str (str): A JSON string representation of the TrackedObjectMetaData instance.\n\n    Returns:\n        TrackedObjectMetaData: A new instance of TrackedObjectMetaData populated with the data from the JSON string.\n    \"\"\"\n    data = json.loads(json_str)\n    return cls.from_dict(data)\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.mean_confidence","title":"<code>mean_confidence(self)</code>","text":"<p>Calculates the mean confidence of the tracked object.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mean confidence of the tracked object.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def mean_confidence(self):\n\"\"\"\n    Calculates the mean confidence of the tracked object.\n\n    Returns:\n        float: The mean confidence of the tracked object.\n    \"\"\"\n    if self.observations &gt; 0:\n        return self.confidence_sum / self.observations\n    else:\n        return 0.0\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.merge","title":"<code>merge(self, other_object)</code>","text":"<p>Merges the metadata of another TrackedObjectMetaData instance into the current one. Updates the current instance with the data from the other TrackedObjectMetaData instance.</p> <p>The following properties are updated:     - observations: Incremented by the observations of the other object.     - confidence_sum: Incremented by the confidence sum of the other object.     - confidence: Set to the confidence of the other object.     - bbox: Set to the bounding box of the other object.     - last_frame_id: Set to the last frame id of the other object.     - class_counts: For each class, the count is incremented by the count of the other object.</p> <p>Parameters:</p> Name Type Description Default <code>other_object</code> <code>TrackedObjectMetaData</code> <p>The other TrackedObjectMetaData instance whose metadata is to be merged with the current instance.</p> required <p>Exceptions:</p> Type Description <code>TypeError</code> <p>If the other_object is not an instance of TrackedObjectMetaData.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def merge(self, other_object):\n\"\"\"\n    Merges the metadata of another TrackedObjectMetaData instance into the current one.\n    Updates the current instance with the data from the other TrackedObjectMetaData instance.\n\n    The following properties are updated:\n        - observations: Incremented by the observations of the other object.\n        - confidence_sum: Incremented by the confidence sum of the other object.\n        - confidence: Set to the confidence of the other object.\n        - bbox: Set to the bounding box of the other object.\n        - last_frame_id: Set to the last frame id of the other object.\n        - class_counts: For each class, the count is incremented by the count of the other object.\n\n    Args:\n        other_object (TrackedObjectMetaData): The other TrackedObjectMetaData instance whose metadata is to be merged with the current instance.\n\n    Raises:\n        TypeError: If the other_object is not an instance of TrackedObjectMetaData.\n\n    \"\"\"  # noqa: E501\n    if not isinstance(other_object, type(self)):\n        raise TypeError(\"Can only merge with another TrackedObjectMetaData.\")\n\n    self.observations += other_object.observations\n    self.confidence_sum += other_object.confidence_sum\n    self.confidence = other_object.confidence\n    self.bbox = other_object.bbox\n    self.last_frame_id = other_object.last_frame_id\n    for class_name in other_object.class_counts.keys():\n        self.class_counts[class_name] = self.class_counts.get(\n            class_name, 0\n        ) + other_object.class_counts.get(class_name, 0)\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.percentage_of_time_seen","title":"<code>percentage_of_time_seen(self, frame_id)</code>","text":"<p>Calculates the percentage of time the tracked object has been seen.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>int</code> <p>The current frame id.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The percentage of time the tracked object has been seen.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def percentage_of_time_seen(self, frame_id: int):\n\"\"\"\n    Calculates the percentage of time the tracked object has been seen.\n\n    Args:\n        frame_id (int): The current frame id.\n\n    Returns:\n        float: The percentage of time the tracked object has been seen.\n    \"\"\"\n    if self.observations &gt; 0:\n        percentage = (self.observations / (frame_id - self.first_frame_id + 1)) * 100\n    else:\n        percentage = 0.0\n    return percentage\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Converts the TrackedObjectMetaData instance to a dictionary.</p> <p>The class_counts dictionary is converted to a string-keyed dictionary. The bounding box list is converted to a list of integers. The first_frame_id, last_frame_id, confidence, confidence_sum, and observations are converted to their respective types.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representation of the TrackedObjectMetaData instance.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def to_dict(self):\n\"\"\"\n    Converts the TrackedObjectMetaData instance to a dictionary.\n\n    The class_counts dictionary is converted to a string-keyed dictionary.\n    The bounding box list is converted to a list of integers.\n    The first_frame_id, last_frame_id, confidence, confidence_sum, and observations are converted to their\n    respective types.\n\n    Returns:\n        dict: A dictionary representation of the TrackedObjectMetaData instance.\n    \"\"\"\n    class_counts_str = {\n        str(class_name): count for class_name, count in self.class_counts.items()\n    }\n    data = {\n        \"first_frame_id\": int(self.first_frame_id),\n        \"last_frame_id\": int(self.last_frame_id),\n        \"class_counts\": class_counts_str,\n        \"bbox\": self.bbox,\n        \"confidence\": float(self.confidence),\n        \"confidence_sum\": float(self.confidence_sum),\n        \"observations\": int(self.observations),\n    }\n    return data\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.to_json","title":"<code>to_json(self)</code>","text":"<p>Converts the TrackedObjectMetaData instance to a JSON string.</p> <p>Returns:</p> Type Description <code>str</code> <p>A JSON string representation of the TrackedObjectMetaData instance.</p> Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def to_json(self):\n\"\"\"\n    Converts the TrackedObjectMetaData instance to a JSON string.\n\n    Returns:\n        str: A JSON string representation of the TrackedObjectMetaData instance.\n    \"\"\"\n    return json.dumps(self.to_dict(), indent=4)\n</code></pre>"},{"location":"reference/tracked_object_metadata/#trackreid.tracked_object_metadata.TrackedObjectMetaData.update","title":"<code>update(self, data_line, frame_id)</code>","text":"<p>Updates the metadata of a tracked object based on new detection data.</p> <p>This method is used to update the metadata of a tracked object whenever new detection data is available. It updates the last frame id, class counts, bounding box, confidence, confidence sum, and observations:     - last_frame_id: Updated to the frame id where the object was detected     - class_counts: Incremented by 1 for the detected class     - bbox: Updated to the bounding box coordinates from the detection data     - confidence: Updated to the confidence level from the detection data     - confidence_sum: Incremented by the confidence level from the detection data     - observations: Incremented by 1</p> <p>Parameters:</p> Name Type Description Default <code>data_line</code> <code>np.ndarra</code> <p>The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.</p> required <code>frame_id</code> <code>int</code> <p>The frame id where the object was detected. This is used to update the last frame id of the tracked object.</p> required Source code in <code>trackreid/tracked_object_metadata.py</code> <pre><code>def update(self, data_line: np.ndarray, frame_id: int):\n\"\"\"\n    Updates the metadata of a tracked object based on new detection data.\n\n    This method is used to update the metadata of a tracked object whenever new detection data is available.\n    It updates the last frame id, class counts, bounding box, confidence, confidence sum, and observations:\n        - last_frame_id: Updated to the frame id where the object was detected\n        - class_counts: Incremented by 1 for the detected class\n        - bbox: Updated to the bounding box coordinates from the detection data\n        - confidence: Updated to the confidence level from the detection data\n        - confidence_sum: Incremented by the confidence level from the detection data\n        - observations: Incremented by 1\n\n    Args:\n        data_line (np.ndarra): The detection data for a single frame. It contains information such as the class name, bounding box coordinates, and confidence level of the detection.\n\n        frame_id (int): The frame id where the object was detected. This is used to update the last frame id of the tracked object.\n\n    \"\"\"  # noqa: E501\n    self.last_frame_id = frame_id\n\n    class_name = int(data_line[input_data_positions.category])\n    self.class_counts[class_name] = self.class_counts.get(class_name, 0) + 1\n    self.bbox = list(data_line[input_data_positions.bbox])\n    confidence = float(data_line[input_data_positions.confidence])\n    self.confidence = confidence\n    self.confidence_sum += confidence\n    self.observations += 1\n</code></pre>"}]}